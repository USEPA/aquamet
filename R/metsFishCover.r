metsFishCover <- function(fishcover, visits) {

################################################################################
# Function: metsFishCover
# Title: Calculate NRSA Fish Cover Metrics
# Programmers: Marlys Cappert
#              Curt Seeliger
#              Suzanne San Romani
#              Tom Kincaid
# Date: December 15, 2009
# Description:
#   This function calculates the fish cover portion of the physical habitat
#   metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires data frames containing the channel cover and stream
#   verification form data files.
# Metrics:
#   pfc_alg, pfc_rck, pfc_brs, pfc_lvt, pfc_aqm, pfc_ohv, pfc_hum, pfc_ucb,
#   pfc_lwd, xfc_alg, xfc_rck, xfc_brs, xfc_lvt, xfc_aqm, xfc_ohv, xfc_hum,
#   xfc_ucb, xfc_lwd, pfc_all, pfc_big, pfc_nat, xfc_all, xfc_big, xfc_nat,
#   sdfc_ucb, sdfc_ohv, idrucb, idrohv, iqrucb, iqrohv
# Function Revisions:
#   12/15/09 mrc: Copied fcMets from NLA project.
#   12/18/09 mrc: Completed creating mets.
#   12/30/09 mrc: Completed tests.
#   03/23/10 cws: Moved creation of unit test dataframes to separate functions.
#   04/01/10 ssr: Created only-boatable and only-wadeable tests. 
#   09/16/10 cws: Removing hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   07/31/12 tmk: Removed use of ODBC data connection and replaced with data
#            input from csv files using a call to function read.csv.  Added
#            argument tbl to the function to identify names of the data files.
#            Added argument NRSAdir to the function to identify the directory
#            from which data files are read and to which the output metrics file
#            is written.
#   12/14/12 tmk: Modified data input to use data frames containing data files
#            rather than csv files.  Modified output to be a data frame rather
#            than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frames to
#            character variables.
# Arguments:
#   fishcover = a data frame containing the fish cover data file.  The
#     data frame must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       FLAG - flag
#   visits = a data frame containing the stream verification form data file.
#     The data frame contains a protocol value for each UID value.  It also
#     should include columns that relate UID to values meaningfull to the user,
#     e.g., site ID, date collected, and visit number.  The data frame must
#     include columns that are named as follows:
#       UID - universal ID value
#       VALXSITE - protocol used during a site visit (BOATABLE, PARBYBOAT,
#         ALTERED, INTWADE, PARBYWADE, WADEABLE)
#   Note that possible values for variables in the input data frames are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   siteProtocol determine sampling protocol values
#   metsFishCover.1 - calculate metrics
################################################################################


# Print an initial message
  cat('Fish Cover calculations:\n')
  
# Convert factors to character variables in the input data frames
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  fishcover <- convert_to_char(fishcover)
  visits <- convert_to_char(visits)

# Determine protocol used for each site
  intermediateMessage('.2 Set protocols.', loc='end')
  protocols <- siteProtocol(unique(fishcover$UID), visits)

# Calculate the metrics
  intermediateMessage('.3 Call function metsFishCover.1.', loc='end')
  mets <- metsFishCover.1(fishcover, protocols)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsFishCover.1 <- function(fishcover, protocols) {
 
 #Returns a dataframe of calculations if successful or a character string describing the problem if one was encountered.
 
 #ARGUMENTS:
 #fishcover   dataframe of the fishcover data.
 #protocols   dataframe relating UID to the sampling protocol used at that site
 
 
 #Did the protocols for fun, but the mets for WADEABLE and BOATABLE are the same for fish cover
 
 #do the calculations
  
#fcMets <- function (df)
# Calculate metrics based on Fish Cover data
#
# ARGUMENTS:
#   None
# 
# Calculates the FishCover metrics


# ASSUMPTIONS:
# The parameter vector has the following values: ALGAE, BOULDR,
# BRUSH, LVTREE, MACPHY, OVRHNG, STRUCT, UNDCUT (Wadeable), UNDERCUT (Boatable), WOODY
# change the value of UNDCUT to UNDERCUT to make them compatible

    intermediateMessage('Fish Cover mets', loc='start')

    fcData <- subset(fishcover
                    ,PARAMETER %in% c('ALGAE', 'BOULDR'
                                      ,'BRUSH', 'LVTREE'
                                      ,'MACPHY', 'OVRHNG'
                                      ,'STRUCT', 'UNDCUT'
                                      ,'UNDERCUT', 'WOODY'
                                     )
                    )
    fcData$PARAMETER <- ifelse(fcData$PARAMETER == 'UNDCUT', 'UNDERCUT' , fcData$PARAMETER)                 

    # Create tables for converting field values to calculation values
    cover04<-data.frame(field=c(NA,'0','1','2','3','4')
                       ,calc=c(NA,0,0.05,0.25,0.575,0.875)
                       ,stringsAsFactors=FALSE
                       )

    presence04<-data.frame(field=c(NA,'0','1','2','3','4')
                          ,calc=c(NA,0,1,1,1,1)
                          ,stringsAsFactors=FALSE
                          )

    fcTypes<-data.frame(PARAMETER=c('ALGAE', 'BOULDR', 'BRUSH'
                                   ,'LVTREE', 'MACPHY', 'OVRHNG'
                                   ,'STRUCT', 'UNDERCUT', 'WOODY'
                                   )
                       ,isBig=c(FALSE, TRUE, FALSE
                               ,FALSE, FALSE, FALSE
                               ,TRUE, TRUE,TRUE
                               )
                       ,isNatural=c(FALSE, TRUE, TRUE
                                   ,TRUE, FALSE, TRUE
                                   ,FALSE ,TRUE, TRUE
                                   )
       
                       )

    intermediateMessage('create tables used in calculations.1', loc='start')

    # Calculate presence mean of each type of fish cover
    # Convert field results to calculable values
    fcPresence<-merge(fcData
                     ,presence04
                     ,by.x='RESULT'
                     ,by.y='field'
                     ,all.x=TRUE
                     ,sort=FALSE
                     )

    fcPMeans<-aggregate(fcPresence$calc
                 ,list('UID'=fcPresence$UID
                      ,"PARAMETER"=fcPresence$PARAMETER
                      )
                 ,mean, na.rm=TRUE
                 )
                 

                          
  meanPresence  <-rename(fcPMeans, 'x','fcfp') 
   
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'ALGAE', 'pfc_alg' , meanPresence$PARAMETER)      
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'BOULDR', 'pfc_rck' , meanPresence$PARAMETER)     
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'BRUSH', 'pfc_brs' , meanPresence$PARAMETER) 
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'LVTREE', 'pfc_lvt' , meanPresence$PARAMETER) 
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'MACPHY', 'pfc_aqm' , meanPresence$PARAMETER)  
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'OVRHNG', 'pfc_ohv' , meanPresence$PARAMETER) 
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'STRUCT', 'pfc_hum' , meanPresence$PARAMETER) 
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'UNDERCUT', 'pfc_ucb' , meanPresence$PARAMETER) 
  meanPresence$PARAMETER <- ifelse(meanPresence$PARAMETER == 'WOODY', 'pfc_lwd' , meanPresence$PARAMETER) 
 
     
     
  meanPresence <- rename(meanPresence, c('PARAMETER','fcfp'),c('METRIC' ,'RESULT'))
                         

    intermediateMessage('complete Mean Presence mets (fp).2')


    # Calculate cover mean of each type of fish cover
    # Convert field results to calculable values.
    fcCover<-merge(fcData, cover04
                   ,by.x='RESULT'
                   ,by.y='field'
                   ,all.x=TRUE, sort=FALSE
                   )

    fcCMeans <-aggregate(fcCover$calc
                      ,list('UID'=fcCover$UID
                           ,"PARAMETER"=fcCover$PARAMETER
                           )
                      ,mean, na.rm=TRUE
                      )
 
      
  meanCover  <- rename(fcCMeans, 'x','fcfc')  
      
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'ALGAE', 'xfc_alg' , meanCover$PARAMETER)      
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'BOULDR', 'xfc_rck' , meanCover$PARAMETER)     
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'BRUSH', 'xfc_brs' , meanCover$PARAMETER) 
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'LVTREE', 'xfc_lvt' , meanCover$PARAMETER) 
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'MACPHY', 'xfc_aqm' , meanCover$PARAMETER)  
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'OVRHNG', 'xfc_ohv' , meanCover$PARAMETER) 
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'STRUCT', 'xfc_hum' , meanCover$PARAMETER) 
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'UNDERCUT', 'xfc_ucb' , meanCover$PARAMETER) 
  meanCover$PARAMETER <- ifelse(meanCover$PARAMETER == 'WOODY', 'xfc_lwd' , meanCover$PARAMETER) 
 
     
     
  meanCover <- rename(meanCover, c('PARAMETER','fcfc'),c('METRIC' , 'RESULT'))
                                            

    intermediateMessage('Complete mean value mets (xp).3')


    # Calculate cover indices: total, large, and natural vegetation
    #grouped presence
    fcPMeans <- merge(fcPMeans, fcTypes, by='PARAMETER', all=TRUE, sort=FALSE)

    fciPAll <- aggregate(list('fciPAll'=fcPMeans$x)
                       ,list('uid'=fcPMeans$UID)
                       ,sum, na.rm=TRUE
                       )
    
    fciPAll$METRIC <- 'pfc_all'
    fciPAll  <- rename(fciPAll, 'fciPAll','RESULT')  
    fciPAll  <- rename(fciPAll, 'uid','UID')     
    
    ttPBig <- subset(fcPMeans, isBig)
    fciPBig <- aggregate(list('fciPBig'=ttPBig$x)
                       ,list('uid'=ttPBig$UID)
                       ,sum, na.rm=TRUE
                       )
    fciPBig$METRIC <- 'pfc_big'
    fciPBig  <- rename(fciPBig,'fciPBig','RESULT')                    
    fciPBig <- rename(fciPBig, 'uid','UID')                        

    ttPNatural <- subset(fcPMeans, isNatural)
    fciPNatural <- aggregate(list('fciPNatural'=ttPNatural$x)
                           ,list('uid'=ttPNatural$UID)
                           ,sum, na.rm=TRUE
                           )
    fciPNatural$METRIC <- 'pfc_nat'
    fciPNatural  <- rename(fciPNatural, 'fciPNatural','RESULT') 
    fciPNatural  <- rename(fciPNatural,'uid','UID')                      
                       
  
 #   fciP <- merge(fciPAll, fciPBig,  by='uid', all=TRUE, sort=FALSE)
 #   fciP <- merge(fciP, fciPNatural, by='uid', all=TRUE, sort=FALSE)
  
    # Calculate cover indices: total, large, and natural vegetation
    # grouped cover
    fcCMeans <- merge(fcCMeans, fcTypes, by='PARAMETER', all=TRUE, sort=FALSE)

    fciCAll <- aggregate(list('fciCAll'=fcCMeans$x)
                       ,list('uid'=fcCMeans$UID)
                       ,sum, na.rm=TRUE
                       )
    
    fciCAll$METRIC <- 'xfc_all'
    fciCAll  <- rename(fciCAll, 'fciCAll','RESULT')  
    fciCAll  <- rename(fciCAll, 'uid','UID')
      
    ttCBig <- subset(fcCMeans, isBig)
    fciCBig <- aggregate(list('fciCBig'=ttCBig$x)
                       ,list('uid'=ttCBig$UID)
                       ,sum, na.rm=TRUE
                       )
    fciCBig$METRIC <- 'xfc_big'
    fciCBig  <- rename(fciCBig, 'fciCBig','RESULT')                    
    fciCBig  <- rename(fciCBig, 'uid','UID')                 

    ttCNatural <- subset(fcCMeans, isNatural)
    fciCNatural <- aggregate(list('fciCNatural'=ttCNatural$x)
                           ,list('uid'=ttCNatural$UID)
                           ,sum, na.rm=TRUE
                           )
    fciCNatural$METRIC <- 'xfc_nat'
    fciCNatural  <- rename(fciCNatural, 'fciCNatural','RESULT')
    fciCNatural  <- rename(fciCNatural, 'uid','UID')                 
                       
  intermediateMessage('complete type metrics.4', loc='start')

    # Calculate cover standard deviation of OHV and UCB
    
  
  
    tt<-aggregate(fcCover$calc
                 ,list('uid'=fcCover$UID
                      ,"parameter"=fcCover$PARAMETER
                      )
                 ,sd, na.rm=TRUE
                 )
  
    sd1 <- subset(tt, parameter %in% c('UNDERCUT', 'OVRHNG'))
    
  sd1$parameter <- ifelse(sd1$parameter == 'UNDERCUT', 'sdfc_ucb' , sd1$parameter) 
  sd1$parameter <- ifelse(sd1$parameter == 'OVRHNG', 'sdfc_ohv' , sd1$parameter) 
  sd1  <- rename(sd1, 'uid','UID')
  sd1  <- rename(sd1, 'x','RESULT') 
  sd1  <- rename(sd1, 'parameter','METRIC') 
     

    intermediateMessage('complete sd calculations.5', loc='start')


    # Calculate iqr, idr for OVRHNG and UNDERCUT midpoints
    
     tt<-aggregate(fcCover$calc
                 ,list('uid'=fcCover$UID
                      ,"parameter"=fcCover$PARAMETER
                      )
                 ,iqr
                 )
  
    idr1 <- subset(tt, parameter %in% c('UNDERCUT', 'OVRHNG'))
  
  idr1$parameter <- ifelse(idr1$parameter == 'UNDERCUT', 'idrucb' , idr1$parameter) 
  idr1$parameter <- ifelse(idr1$parameter == 'OVRHNG', 'idrohv' , idr1$parameter) 
  idr1  <- rename(idr1, 'uid','UID')
  idr1  <- rename(idr1, 'x','RESULT') 
  idr1  <- rename(idr1, 'parameter','METRIC') 
  
  #iqr
  
       tt<-aggregate(fcCover$calc
                 ,list('uid'=fcCover$UID
                      ,"parameter"=fcCover$PARAMETER
                      )
                 ,iqr
                 )
  
    iqr1 <- subset(tt, parameter %in% c('UNDERCUT', 'OVRHNG'))
  
  iqr1$parameter <- ifelse(iqr1$parameter == 'UNDERCUT', 'iqrucb' , iqr1$parameter) 
  iqr1$parameter <- ifelse(iqr1$parameter == 'OVRHNG', 'iqrohv' , iqr1$parameter) 
  iqr1  <- rename(iqr1, 'uid','UID')
  iqr1  <- rename(iqr1, 'x','RESULT') 
  iqr1  <- rename(iqr1, 'parameter','METRIC') 
  
  
  
    intermediateMessage('complete id and iq calculations.6', loc='start')

    # combine results into a dataframe
    
    
  mets <- rbind (meanPresence
                         , meanCover                  
                         ,fciPNatural
                         ,fciPBig
                         ,fciPAll
                         ,fciCNatural
                         ,fciCBig
                         ,fciCAll
                         ,sd1
                         ,idr1
                         ,iqr1)
    
  
    intermediateMessage(' Done.', loc='end')

    return(mets)
}



# end of file
