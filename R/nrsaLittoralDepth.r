nrsaLittoralDepth <- function(bLittoralDepth=NULL) {

################################################################################
# Function: nrsaLittoralDepth
# Title: Calculate NRSA Littoral Depth Metrics
# Programmers: Randy Hjort
#              Curt Seeliger
#              Tom Kincaid
# Date: January 25, 2010
# Description:
#   This function calculates the littoral depth portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires a data frame containing the channel depth data file.
# Wadeable Metrics:
#   None
# Boatable Metrics:
#   xlit mxlit mnlit vlit
# Function Revisions:
#   01/25/10 rch: Copied, plagerized and made up this code.
#   02/18/10 cws: Removed source() of NRSAValidation.r and summaryby.r.
#   06/01/10 cws: Removed odd code that somehow showed up here.
#   09/16/10 cws: Removed hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   11/04/10 cws: Handles missing littoral file (ie when study has no boatable
#            sites) with some grace.
#   11/18/10 cws: Added require(Hmisc) for %nin% operator.
#   07/27/12 tmk: Removed calls to the require() function.  Removed use of ODBC
#            data connection and replaced with data input from csv files using a
#            call to function read.csv.  Added argument tbl to the function to
#            identify name of the data file.  Added argument NRSAdir to the
#            function to identify the directory from which the data file is read
#            and to which the output metrics file is written.
#   12/21/12 tmk: Modified data input to use a data frame containing the data
#            file rather than a csv file.  Modified output to be a data frame
#            rather than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frame to
#            character variables.
#    2/22/16 cws: Rewritten with new calling interface.  Removed use of summaryby
#            function
#
# Arguments:
#   chandepth = a data frame containing the channel depth data file.  The
#     data frame must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       LINE - way point (1,2, etc.) between transects
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   Note that possible values for variables in the input data frame are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   metsLittoralDepth.1 - calculate metrics
################################################################################
# 
# # Print an initial message
#   intermediateMessage('Littoral Depth calculations', loc='start')
#   cat('Littoral Depth calculations:\n')
# 
# # Convert factors to character variables in the chandepth data frame
#   intermediateMessage('.1 Convert factors to character variables.', loc='end')
#   chandepth <- convert_to_char(chandepth)
# 
# # Calculate the metrics
#   intermediateMessage('.1 Call function metsLittoralDepth.1.', loc='end')
#   mets <- metsLittoralDepth.1(chandepth)
#   row.names(mets) <- 1:nrow(mets)
# 
# # Print an exit message
#   intermediateMessage('Done.', loc='end')
# 
# # Return results
#   return(mets)
# }
# 
# 
# 
# metsLittoralDepth.1 <- function(indat) {
# 
# # Does all the real work for metsLittoralDepth.
# # Returns a dataframe of calculations if successful
# # or a character string describing the problem if
# # one was encountered.
# #
# # ARGUMENTS:
# # indat		dataframe of littoral data.
# # protocols	dataframe relating UID to the
# #			  sampling protocol used at the site.
# #

  intermediateMessage('Littoral Depth mets', loc='start')

    absentAsNULL <- function(df, ifdf, ...) {
        if(is.null(df)) return(NULL)
        else if(!is.data.frame(df)) return(NULL)
        else if(nrow(df) == 0) return (NULL)
        else if(is.function(ifdf)) return(ifdf(df, ...))
        else return(df)
    }
    ifdf <- function(df, ...) {
        rc <- df %>% 
              select(SITE, VALUE) %>%
              mutate(VALUE = as.numeric(VALUE))
        return(rc)
    }

    depths <- absentAsNULL(bLittoralDepth, ifdf)
    if(is.null(depths)) return (NULL)

    intermediateMessage('.1')

#     mdx <- summaryby(depths, 'mean', "xlit")
#     mds <- summaryby(depths, 'sd', "vlit")
#     mdm <- summaryby(depths, 'max', "mxlit")
#     mdn <- summaryby(depths, 'min', "mnlit")
# 
#     intermediateMessage('.2')
#     mets <- rbind(mdx,mds,mdm,mdn)
    mets <- depths %>%
            group_by(SITE) %>%
            dplyr::summarise(xlit = protectedMean(VALUE, na.rm=TRUE)
                            ,vlit = sd(VALUE, na.rm=TRUE)
                            ,mxlit = max(VALUE, na.rm=TRUE)
                            ,mnlit = min(VALUE, na.rm=TRUE)
                            ) %>%
            melt('SITE', variable.name='METRIC', value.name='VALUE')
    
    intermediateMessage('.2')

    intermediateMessage('. Done.', loc='end')

    return(mets)
 
}

# end of file