metsLittoralMacrohabitat <- function(df) {

################################################################################
# Function: metsLittoralMacrohabitat
# Title: Calculate NLA Littoral Fish Macrohabitat Metrics
# Programmers: Curt Seeliger
#              Tom Kincaid
# Date: October 7, 2008
# Description:
#   This function calculates the littoral fish macrohabitat portion of the
#   physicalhabitat metrics for National Lakes Assessment (NLA) data.  The
#   function requires a data frame containing validated physical habitat data
#   collected using the NLA protocol.
# Function Revisions:
#   10/07/08 cws: Added lmnHuman calculation.
#   10/21/08 cws: Correcting counts of missing parameters.  These are now zero.
#   11/04/08 cws: Correcting value of highest rank of HUMAN_DISTURBANCE from
#            HIGH to HEAVY.
#   11/07/08 cws: Renaming lmnClass to lmnCover, renaming old lmnCover to 
#            lmnCoverTypes.  
#   11/12/08 cws: Allowing lmoCover to have multiple values just like other
#            mode mets.
#   03/08/13 cws: Copied from 2007 study and renamed.
#   02/19/14 cws: Recreated from R environment saved 5 February after 
#            accidentally blowing away the source files on the 3rd. holy shit
#   02/20/14 cws: Metrics not used as 2012 phab does not include these data. 
#   06/12/14 tmk: Removed calls to the require() function.
# Arguments:
#   df = a data frame containing littoral fish macrohabitat data.  The
#     data frame must include columns that are named as follows:
#       UID - universal ID value, which uniquely identifies the site location, 
#             date of visit, visit order, habitat type, etc. for which metrics 
#             will be calculated.  For NLA, site ID, year and visit number are
#             used for this purpose.
#       STATION - the subordinate ID value, which identifies the location,
#               habitat type, order of occurence, etc. within a single UID.
#               For NLA, transect is used for this purpose.
#       PARAMETER - parameter name, which identifies the variables used in
#                   calculations. In wide data frame format, this argument
#                   would be used to name columns.  It is assumed that this
#                   argument has the following values: DOM_SUBSTRATE,
#                   COVER_CLASS, HUMAN_DISTURBANCE, COVER_ARTIFICIAL,
#                   COVER_BOULDERS, COVER_FILL, COVER_NONE, COVER_VEG,
#                   and COVER_WOODY.
#       RESULT - parameter values, which are the values used in calculations.
# Output:
#   A data frame that contains the following columns:
#     UID - universal ID value
#     PARAMETER - metric name
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
################################################################################

  # Print initial messages
  cat('Littoral Fish Macrohabitat calculations:\n')
  intermediateMessage('Littoral Fish Macrohabitat mets', loc='start')

	substrate <- metsLittoralMacrohabitat.substrate(df)
	cover <- metsLittoralMacrohabitat.cover(df)
	humanDist <- metsLittoralMacrohabitat.humanDist(df)
	coverTypes <- metsLittoralMacrohabitat.coverTypes(df)
	
	rc <- rbind(substrate, cover, humanDist, coverTypes)
	
	intermediateMessage(' Done.', loc='end')
	
	return(rc)
}



metsLittoralMacrohabitat.cover <- function(df)
# Cover class calculations using COVER_CLASS
{
	coverClass <- subset(df, PARAMETER=='COVER_CLASS')
	
	# No mets if no data
	if(nrow(coverClass) == 0) return(NULL)
	
	
	countCover <- aggregate(list(RESULT = coverClass$RESULT)
			,list(UID = coverClass$UID)
			,count
	)
	countCover <- within(countCover
			,{PARAMETER <- 'LMNCOVER'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	
	noCover <- aggregate(list(RESULT = coverClass$RESULT=='NO COVER')
			,list(UID = coverClass$UID)
			,mean, na.rm=TRUE
	)
	noCover <- within(noCover
			,{PARAMETER <- 'LMFPLITTLE'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	
	patchyCover <- aggregate(list(RESULT = coverClass$RESULT=='PATCHY COVER')
			,list(UID = coverClass$UID)
			,mean, na.rm=TRUE
	)
	patchyCover <- within(patchyCover
			,{PARAMETER <- 'LMFPPATCHY'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	
	contCover <- aggregate(list(RESULT = coverClass$RESULT=='CONTINUOUS COVER')
			,list(UID = coverClass$UID)
			,mean, na.rm=TRUE
	)
	contCover <- within(contCover
			,{PARAMETER <- 'LMFPCONTINUOUS'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	
	# Determine cover amount mode
	tt <- within(rbind(noCover, patchyCover, contCover)
			,coverAmount <- ifelse(PARAMETER == 'LMFPCONTINUOUS', 'CONTINUOUS COVER'
					,ifelse(PARAMETER == 'LMFPLITTLE', 'NO COVER'
							,ifelse(PARAMETER == 'LMFPPATCHY', 'PATCHY COVER', 'UNKNOWN COVER'
							))) 
	)
	modeCover <- within(modalClasses(tt, 'coverAmount', 'RESULT')
			,{RESULT <- modalClasses
				PARAMETER <- 'LMOCOVER'
				modalClasses <- NULL
			}
	)
	
	
	rc <- rbind(modeCover, countCover, noCover, patchyCover, contCover)
	
	intermediateMessage('.3')
	
	return(rc)
}


metsLittoralMacrohabitat.coverTypes <- function(df)
# Cover types.  Zero or more are recorded at each station, though ideally at least one is.
{
	coverTypes <- subset(df, PARAMETER %in% c('COVER_ARTIFICIAL', 'COVER_BOULDERS'
					,'COVER_FILL', 'COVER_NONE'
					,'COVER_VEG', 'COVER_WOODY'
			)
			,select=c('UID','STATION','PARAMETER','RESULT')
	)
	
	# No mets if no data
	if(nrow(coverTypes) == 0) return(NULL)				
	
	
	# Count stations at which we have ANY cover types recorded
	nCoverLocs <- aggregate(list(RESULT = I(coverTypes$STATION))
			,list(UID = coverTypes$UID)
			,function(x) #count
			{
				return(length(unique(x)))
			}
	)
	nCoverLocs$PARAMETER <- 'LMNCOVERTYPES'
	
	
	tt <- aggregate(list(RESULT = I(coverTypes$RESULT=='X'))
			,list('UID'=coverTypes$UID, 'PARAMETER'=coverTypes$PARAMETER)
			,count
	)
	
	tt <-merge(tt, within(nCoverLocs, {totN <- RESULT; PARAMETER <- NULL; RESULT <- NULL;})
			,by='UID'
			,all.x=TRUE
			,sort=FALSE
	)
	tt$RESULT <- ifelse(tt$totN==0
			,0
			,tt$RESULT / tt$totN
	)
	tt$RESULT[is.na(tt$RESULT)] <- 0
	
	
	typeMeans <- reshape(subset(tt, select=c('UID','PARAMETER','RESULT'))
			,idvar='UID'
			,direction='wide'
			,timevar='PARAMETER'
	)
	typeMeans <- rename(typeMeans
			,c('RESULT.COVER_ARTIFICIAL', 'RESULT.COVER_BOULDERS'
					,'RESULT.COVER_FILL', 'RESULT.COVER_NONE'
					,'RESULT.COVER_VEG', 'RESULT.COVER_WOODY'
			)
			,c('LMFPARTIFICIAL', 'LMFPBOULDERS'
					,'LMFPFILL', 'LMFPNONE'
					,'LMFPVEG', 'LMFPWOODY'
			)
	)
	typeMeans <- within(melt(typeMeans, 'UID', variable.name='PARAMETER', value.name='RESULT'), PARAMETER <- as.character(PARAMETER))
	intermediateMessage('.6')
	
	
	rc <- rbind(nCoverLocs, typeMeans)
	return(rc)
}


metsLittoralMacrohabitat.humanDist <- function(df)
# Human disturbance level mets based on HUMAN_DISTURBANCE
{
	humDist    <- subset(df
			,PARAMETER=='HUMAN_DISTURBANCE'
			,select=c('UID','STATION','PARAMETER','RESULT')
	)
	
	# No mets if no data
	if(nrow(humDist) == 0) return(NULL)				
	
	
	hdWeights <- data.frame(field=c('NONE','LOW','MODERATE','HEAVY')
			,calc =c(0, 0.2, 0.5, 1.0)
	)
	humDist <- merge(humDist, hdWeights, by.x='RESULT', by.y='field')
	
	
	weightedDist <- aggregate(list(RESULT = humDist$calc)
			,list(UID = humDist$UID)
			,mean, na.rm=TRUE
	)
	weightedDist$PARAMETER <- 'LMPWHUMAN'
	
	
	nWeightedDist <- aggregate(list(RESULT = humDist$calc)
			,list(UID = humDist$UID)
			,count
	)
	nWeightedDist$PARAMETER <- 'LMNHUMAN'
	
	intermediateMessage('.5')
	
	
	rc <- rbind(weightedDist, nWeightedDist)
	return(rc)
}


metsLittoralMacrohabitat.substrate <- function(df)
# Determine fractional presence of various substrates
{
	domSub <- subset(df, PARAMETER=='DOM_SUBSTRATE')
	
	# No mets if no data
	if(nrow(domSub) == 0) return(NULL)
	
	countSub <- aggregate(list(RESULT = domSub$RESULT)
			,list(UID=domSub$UID)
			,count
	)
	countSub <- within(countSub
			,{PARAMETER <- 'LMNSUBSTRATE'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	bSub <- aggregate(list(RESULT = domSub$RESULT=='B')
			,list(UID = domSub$UID)
			,mean, na.rm=TRUE
	)
	bSub <- within(bSub
			,{PARAMETER <- 'LMFPBEDROCK'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	cSub <- aggregate(list(RESULT = domSub$RESULT=='C')
			,list(UID =domSub$UID)
			,mean, na.rm=TRUE
	)
	cSub <- within(cSub
			,{PARAMETER <- 'LMFPCOBBLE'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	mSub <- aggregate(list(RESULT = domSub$RESULT=='M')
			,list(UID = domSub$UID)
			,mean, na.rm=TRUE
	)
	mSub <- within(mSub
			,{PARAMETER <- 'LMFPMUD'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	sSub <- aggregate(list(RESULT = domSub$RESULT=='S')
			,list(UID = domSub$UID)
			,mean, na.rm=TRUE
	)
	sSub <- within(sSub
			,{PARAMETER <- 'LMFPSAND'
				RESULT <- ifelse(is.na(RESULT), 0, RESULT)
			}
	)
	
	intermediateMessage('.1')
	
	fracSubs <- rbind(bSub, cSub, mSub, sSub, countSub)
	
	
	# determine substrate type mode
	tt <- within(subset(fracSubs, grepl('^LMFP', PARAMETER))
			,PARAMETER <- gsub('^LMFP(.+)$', '\\1', PARAMETER)
	)
	tt <- within(tt, PARAMETER <- capitalize(tolower(PARAMETER)))	
	
	modeSub <- modalClasses(tt, "PARAMETER", "RESULT")
	modeSub <- within(modeSub
			,{PARAMETER <- 'LMOSUBSTRATE'
				RESULT <- gsub('Cobble', 'C'	# convert to 2007 expectations
						,gsub('Mud', 'M'
								,gsub('Sand', 'S'
										,gsub('Bedrock', 'B', modalClasses
										))))
				modalClasses <- NULL
			}
	)
	
	
	intermediateMessage('.2')
	
	rc <- rbind(fracSubs, modeSub)
	return(rc)
}



# end of file
