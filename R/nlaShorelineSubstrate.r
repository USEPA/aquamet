nlaShorelineSubstrate <- function(bedrock = NULL
	                             ,boulder = NULL
	                             ,cobble = NULL
	                             ,gravel = NULL
	                             ,organic = NULL
	                             ,other = NULL
	                             ,sand = NULL
	                             ,silt = NULL
	                             ,wood = NULL
	                             ) {

################################################################################
# Function: nlaShorelineSubstrate
# Title: Calculate NLA Shoreline Substrate Metrics
# Programmers: Curt Seeliger
#              Tom Kincaid
# Date: October 7, 2008
# Description:
#   This function calculates the shoreline substrate portion of the physical
#   habitat metrics for National Lakes Assessment (NLA) data.  The function
#   requires a data frame containing validated physical habitat data collected
#   using the NLA protocol.
# Function Revisions:
#   10/07/08 cws: quantile calculations using type 3 algorithm to mimic SAS 
#            results.
#   10/16/08 cws: changed to use normalizedCover() for all cover mets; was just
#            normalizing the diameter percentile mets using inline code.
#   10/17/08 cws: changed to use type 2 quantile calculation method, as this
#            actually matches SAS output using proc univariate.
#   10/21/08 cws: Correcting counts of missing parameters.  These are now zero.
#   02/27/09 cws: Calculation of ssiSiteVariety corrected.
#   03/08/13 cws: Copied from 2007 study and renamed.
#   12/06/13 cws: Added unit test based on 2007 data, RESULTs assumed to be
#            correct with the exception of NA counts, which in 2007 were set
#            to 0 later on (in nlaphab.r).  The metrics function was changed
#            to set those counts to integer 0 within the function and to 
#            return a long dataframe instead of a wide one.  The metrics
#            function was also changed to not return NA values for substrates
#            which were not recorded at a site (e.g. 7533 has no gravel, so
#            ssfcGravel, ssvGravel and ssfpGravel were NA but now are no longer
#            reported).  These NA values were an artifact of the 'wide'
#            organization of the output, and are commented out in the code
#            creating the expected values.
#   12/11/13 cws: Completed unit test with 2007 data. Corrected SAS results for
#            SSISITEVARIETY values for 7533, 7682 and 7961. Upcased metric
#            names.  Regression test using entire 2007 dataset shows the
#            following differences which are all expected:  SSISITEVARIETY is
#            changed from NA to the correct count in 19 sites (7518, 7533, 7534,
#            7598, 7682, 7724, 7760, 7791, 7818, 7862, 7895, 7926, 7956, 7961,
#            8069, 8101, 8797, 8845, 8846) which are the only sites with absent
#            substrate data.  Also SSN* counts at 57 sites which have no
#            shoreline substrate data are NA instead of 0.  Also the values of
#            SSOPCLASS and SSOFCLASS have all changed from NA to actual values.
#   06/12/14 tmk: Removed calls to the require() function.
#    7/17/17 cws Renamed from metsShorelineSubstrate and updated to new calling
#            interface, changing UID, and RESULT to SITE and VALUE, and changing
#            output column PARAMETER to METRIC
#
# Arguments:
#   df = a data frame containing shoreline substrate data.  The data frame must
#     include columns that are named as follows:
#       SITE - universal ID value, which uniquely identifies the site location, 
#             date of visit, visit order, habitat type, etc. for which metrics 
#             will be calculated.  For NLA, site ID, year and visit number are
#             used for this purpose.
#       STATION - the subordinate ID value, which identifies the location,
#               habitat type, order of occurence, etc. within a single SITE.
#               For NLA, transect is used for this purpose.
#       PARAMETER - parameter name, which identifies the variables used in
#                   calculations. In wide data frame format, this argument
#                   would be used to name columns.  It is assumed that this
#                   argument has the following values: SS_BEDROCK, SS_BOULDERS, 
#                   SS_COBBLE, SS_GRAVEL, SS_SAND, SS_SILT, SS_ORGANIC,
#                   SS_OTHER, and SS_WOOD.
#       VALUE - parameter values, which are the values used in calculations.
#       UNITS - parameter units, which identifies the units in which the
#               parameter values are recorded.
# Output:
#   A data frame that contains the following columns:
#     SITE - universal ID value
#     PARAMETER - metric name
#     VALUE - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
################################################################################

    # Print initial messages
    intermediateMessage('Shoreline substrate metrics', loc='start')
    
    addClass <- function(df, ...) {
        
        args <- list(...)
        if(is.null(args)) return(NULL)
        else if(all(is.na(args))) return(NULL)
        
        rc <- df %>% mutate(CLASS = args[[1]])
        return(rc)
    }

    bedrock <- bedrock %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_BEDROCK')
	boulder <- boulder %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_BOULDERS')
	cobble <- cobble %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_COBBLE')
	gravel <- gravel %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_GRAVEL')
	organic <- organic %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_ORGANIC')
	other <- other %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_OTHER')
	sand <- sand %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_SAND')
	silt <- silt %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_SILT')
	wood <- wood %>% aquametStandardizeArgument(ifdf=addClass, struct=list(SITE=c('integer','character'), STATION='character', VALUE=c('integer','character')),  'SS_WOOD')
	
	df <- rbind(bedrock, boulder, cobble, gravel, organic, other, sand, silt, wood)
	
    ssData <- subset(df
                  ,CLASS %in% c('SS_BEDROCK', 'SS_BOULDERS', 'SS_COBBLE'
                                   ,'SS_GRAVEL', 'SS_SAND', 'SS_SILT'
                                   ,'SS_ORGANIC', 'SS_OTHER', 'SS_WOOD'
                                   )
                  )

  intermediateMessage('.1')

  # Set up recodings for presence, cover and characteristic diameter (both
  # actual and logged)
  presence04 <- data.frame(field=c(NA,'0','1','2','3','4')
                          ,calc=c(NA,0,1,1,1,1)
                          ,stringsAsFactors=FALSE
                          )

  cover04<-data.frame(field=c(NA,'0','1','2','3','4')
                     ,calc=c(NA,0,0.05,0.25,0.575,0.875)
                     ,stringsAsFactors=FALSE
                     )

  tt<-data.frame(class=c('SS_BEDROCK',       'SS_BOULDERS'
                        ,'SS_COBBLE',        'SS_GRAVEL'
                        ,'SS_SAND',          'SS_SILT'
                        ,'SS_ORGANIC',       'SS_WOOD',           'SS_OTHER'
                        )
                ,diam=c(gmean(c(4000,8000)), gmean(c(250,4000))
                       ,gmean(c(64,250)),    gmean(c(2,64))
                       ,gmean(c(0.06,2)),    gmean(c(0.001,0.06))
                       ,NA,                  NA,                  NA
                       )
                ,stringsAsFactors=FALSE
                       )
  diameters <- aggregate(list(lDiam = tt$diam)
                        ,list('class'=tt$class, 'diam'=tt$diam)
                        ,log10
                        )
  intermediateMessage('.2')

  
  # Calculate fractional presence of each substrate class
  ssPresence <- merge(ssData, presence04
                     ,by.x='VALUE', by.y='field'
                     ,all.x=TRUE)
  tt <- aggregate(list(VALUE = ssPresence$calc)
                 ,list('SITE'=ssPresence$SITE
                      ,'CLASS'=ssPresence$CLASS
                      ) 
                 ,mean, na.rm=TRUE
                 )
  meanPresence <- within(tt
				        ,METRIC <- ifelse(CLASS == 'SS_BEDROCK', 'SSFPBEDROCK'
							      ,ifelse(CLASS == 'SS_BOULDERS', 'SSFPBOULDERS'
								  ,ifelse(CLASS == 'SS_COBBLE', 'SSFPCOBBLE'
								  ,ifelse(CLASS == 'SS_GRAVEL', 'SSFPGRAVEL'
								  ,ifelse(CLASS == 'SS_SAND', 'SSFPSAND'
								  ,ifelse(CLASS == 'SS_SILT', 'SSFPSILT'
								  ,ifelse(CLASS == 'SS_ORGANIC', 'SSFPORGANIC'
								  ,ifelse(CLASS == 'SS_WOOD', 'SSFPWOOD'
								  ,ifelse(CLASS == 'SS_OTHER', 'SSFPOTHER', 'SSFPUNKNOWN'
								   )))))))))
					    ) %>% 
                  select(SITE, METRIC, VALUE)

  intermediateMessage('.3')


  # Calculate variety metrics: 
  #     ssiStaVariety = mean number of substrate classes at each station.
  #     ssiSiteVariety = total number of substrate classes present in site
  # The number of substrate classes at a station is the sum of their presences.
  # Note: SS_OTHER is not included in site variety index
  tt <- aggregate(list(sum=ssPresence$calc)
                 ,list('SITE'=ssPresence$SITE
                      ,'STATION'=ssPresence$STATION
                      )
                 ,sum, na.rm=TRUE
                 )
  ssiVariety <- aggregate(list(VALUE=tt$sum)
                            ,list('SITE'=tt$SITE)
                            ,mean, na.rm=TRUE
                            )
  ssiVariety$METRIC <- 'SSISTAVARIETY'

  tt <- subset(meanPresence, METRIC != 'SSFPOTHER')
  ssiSiteVariety <- aggregate(list(VALUE = tt$VALUE)
  							 ,list(SITE=tt$SITE)
					 		 ,function(x) {
								 sum(ifelse(x>0, 1, 0), na.rm=TRUE)		# sum up substrate presences
							  }
					  		 )
  ssiSiteVariety$METRIC <- 'SSISITEVARIETY'
  ssiVariety <- rbind(ssiVariety, ssiSiteVariety)

  intermediateMessage('.4')


  # Normalize covers of all shore substrate classes. 
  sscover <- merge(ssData, cover04, by.x='VALUE', by.y='field', all.x=TRUE)
  sscover <- normalizedCover(sscover, 'calc', 'normCover')
  
  # calculate mean cover of each substrate class
  tt <- aggregate(list(VALUE = sscover$normCover)
                 ,list('SITE'=sscover$SITE
                      ,'CLASS'=sscover$CLASS
                      ) 
                 ,mean, na.rm=TRUE
                 )
#
  meanCover <- within(tt
					 ,METRIC <- ifelse(CLASS == 'SS_BEDROCK', 'SSFCBEDROCK'
					 		   ,ifelse(CLASS == 'SS_BOULDERS', 'SSFCBOULDERS'
							   ,ifelse(CLASS == 'SS_COBBLE', 'SSFCCOBBLE'
							   ,ifelse(CLASS == 'SS_GRAVEL', 'SSFCGRAVEL'
							   ,ifelse(CLASS == 'SS_SAND', 'SSFCSAND'
							   ,ifelse(CLASS == 'SS_SILT', 'SSFCSILT'
							   ,ifelse(CLASS == 'SS_ORGANIC', 'SSFCORGANIC'
							   ,ifelse(CLASS == 'SS_WOOD', 'SSFCWOOD'
							   ,ifelse(CLASS == 'SS_OTHER', 'SSFCOTHER', 'SSFCUNKNOWN'
							    )))))))))
					 ) %>% 
                  select(SITE, METRIC, VALUE)

  intermediateMessage('.5')

  # calculate stdev cover of each substrate class
  tt <- aggregate(list(VALUE = sscover$normCover)
                 ,list('SITE'=sscover$SITE
                      ,'CLASS'=sscover$CLASS
                      ) 
                 ,sd, na.rm=TRUE
                 )
  sdCover <- within(tt
				   ,{METRIC <- ifelse(CLASS == 'SS_BEDROCK', 'SSVBEDROCK'
						      ,ifelse(CLASS == 'SS_BOULDERS', 'SSVBOULDERS'
							  ,ifelse(CLASS == 'SS_COBBLE', 'SSVCOBBLE'
							  ,ifelse(CLASS == 'SS_GRAVEL', 'SSVGRAVEL'
							  ,ifelse(CLASS == 'SS_SAND', 'SSVSAND'
							  ,ifelse(CLASS == 'SS_SILT', 'SSVSILT'
							  ,ifelse(CLASS == 'SS_ORGANIC', 'SSVORGANIC'
							  ,ifelse(CLASS == 'SS_WOOD', 'SSVWOOD'
							  ,ifelse(CLASS == 'SS_OTHER', 'SSVOTHER', 'SSVUNKNOWN'
							   )))))))))
					   
				    }
		   		   ) %>% 
                  select(SITE, METRIC, VALUE)

  intermediateMessage('.6')


  # count valid cover of each substrate class.  Fill in missing (NA) counts with 0, as was
  # done elsewhere in 2007.
  tt <- aggregate(list(VALUE = sscover$normCover)
                 ,list('SITE'=sscover$SITE
                      ,'CLASS'=sscover$CLASS
                      ) 
                 ,count
                 )
  tt <- within(expand.data.frame(tt, c('SITE','CLASS'))
			  ,VALUE <- ifelse(is.na(VALUE), 0, VALUE)
			  )
  countSubstrates <- within(tt
						   ,{METRIC <- ifelse(CLASS == 'SS_BEDROCK', 'SSNBEDROCK'
									  ,ifelse(CLASS == 'SS_BOULDERS', 'SSNBOULDERS'
									  ,ifelse(CLASS == 'SS_COBBLE', 'SSNCOBBLE'
									  ,ifelse(CLASS == 'SS_GRAVEL', 'SSNGRAVEL'
									  ,ifelse(CLASS == 'SS_SAND', 'SSNSAND'
									  ,ifelse(CLASS == 'SS_SILT', 'SSNSILT'
									  ,ifelse(CLASS == 'SS_ORGANIC', 'SSNORGANIC'
									  ,ifelse(CLASS == 'SS_WOOD', 'SSNWOOD'
									  ,ifelse(CLASS == 'SS_OTHER', 'SSNOTHER', 'SSNUNKNOWN'
									   )))))))))
						    }
						   ) %>% 
                  select(SITE, METRIC, VALUE)
						   
						   
  intermediateMessage('.7')


  # Calculations using characteristic diameters of the substrate are based
  # on mean diameter*cover values at each transect.  Cover values are 
  # normalized prior to their use as weights for these means.
  #
  # Determine mean diameters, weighted by the normalized covers.  Note that
  # the normalization includes non-mineral substrates, but the following
  # calculations do not take them into account as they have no meaningful 
  # diameter.
  mineralCover <- subset(sscover
                        ,CLASS %in% c('SS_BEDROCK','SS_BOULDERS','SS_COBBLE'
                                         ,'SS_GRAVEL', 'SS_SAND', 'SS_SILT'
                                         )
                        ,select=names(sscover)[names(sscover) != 'normCover']
                  )
  mineralCover <- normalizedCover(mineralCover, 'calc', 'normCover')
  
  tt <- merge(mineralCover, diameters
             ,by.x='CLASS', by.y='class'
             ,all.x=TRUE
             )
  tt$wtLDiam <- tt$lDiam * tt$normCover

  diamSubstrate <- aggregate(list(meanLDiam = tt$wtLDiam)
                            ,list('SITE'=tt$SITE
                                 ,'STATION'=tt$STATION
                                 ) 
                            ,mean, na.rm=TRUE
                            )

  intermediateMessage('.8')


  # Estimate measures of diameter populations
  meanLDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,mean, na.rm=TRUE
                 )
  meanLDia$METRIC <- 'SSXLDIA'

  sdLDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,sd, na.rm=TRUE
                 )
  sdLDia$METRIC <- 'SSVLDIA'

  p16LDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,quantile, 0.16, na.rm=TRUE, names=FALSE, type=2
                 )
  p16LDia$METRIC <- 'SS16LDIA'

  p25LDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,quantile, 0.25, na.rm=TRUE, names=FALSE, type=2
                 )
  p25LDia$METRIC <- 'SS25LDIA'

  p50LDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,quantile, 0.50, na.rm=TRUE, names=FALSE, type=2
                 )
  p50LDia$METRIC <- 'SS50LDIA'

  p75LDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,quantile, 0.75, na.rm=TRUE, names=FALSE, type=2
                 )
  p75LDia$METRIC <- 'SS75LDIA'

  p84LDia <- aggregate(list(VALUE = diamSubstrate$meanLDiam)
                 ,list('SITE'=diamSubstrate$SITE)
                 ,quantile, 0.84, na.rm=TRUE, names=FALSE, type=2
                 )
  p84LDia$METRIC <- 'SS84LDIA'


  intermediateMessage('.9')


  # Determine most common substrate class by presence and by cover
  # (requires same site visits in meanPresence and meanCover in same order)
  #
  # Initialize these metrics with missing values, and add classes
  tt <- dcast(rbind(meanPresence,meanCover), SITE~METRIC, value.var='VALUE')
  modeClasses <- subset(tt, select='SITE')
  modeClasses$SSOPCLASS <- NA
  modeClasses$SSOFCLASS <- NA

  for(i in 1:nrow(tt)) {
      modeClasses$SSOPCLASS[i] <- modalClass(tt[i,]
                                            ,c('SSFPBEDROCK', 'SSFPBOULDERS'
                                              ,'SSFPCOBBLE',  'SSFPGRAVEL'
                                              ,'SSFPSAND',    'SSFPSILT'
                                              ,'SSFPORGANIC', 'SSFPWOOD'
                                              ,'SSFPOTHER'
                                              )
                                            ,c('Bedrock', 'Boulders'
                                              ,'Cobble',  'Gravel'
                                              ,'Sand',    'Silt'
                                              ,'Organic', 'Wood'
                                              ,'Other'
                                              )
                                            )
      modeClasses$SSOFCLASS[i] <- modalClass(tt[i,]
                                            ,c('SSFCBEDROCK', 'SSFCBOULDERS'
                                              ,'SSFCCOBBLE',  'SSFCGRAVEL'
                                              ,'SSFCSAND',    'SSFCSILT'
                                              ,'SSFCORGANIC', 'SSFCWOOD'
                                              ,'SSFCOTHER'
                                              )
                                            ,c('Bedrock', 'Boulders'
                                              ,'Cobble',  'Gravel'
                                              ,'Sand',    'Silt'
                                              ,'Organic', 'Wood'
                                              ,'Other'
                                              )
                                            )
  }

  modeClasses <- within(melt(modeClasses, 'SITE'
						    ,variable.name='METRIC'
			                ,value.name='VALUE'
			                )
					   ,METRIC <- as.character(METRIC)
			   		   )
					   
  intermediateMessage('.10')

  # combine VALUEs into a dataframe
  ssMets <- rbind(meanPresence, meanCover, ssiVariety, sdCover, countSubstrates
				 ,meanLDia, sdLDia, p16LDia, p25LDia, p50LDia, p75LDia, p84LDia
				 ,modeClasses
				 )
  intermediateMessage(' Done.', loc='end')

  return(ssMets)

}



# end of file
