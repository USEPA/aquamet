metsBankFeatures <- function(df, data2007=FALSE) {

################################################################################
# Function: metsBankFeatures
# Title: Calculate NLA Bank Features Metrics
# Programmers: Curt Seeliger
#              Tom Kincaid
# Date: October 21, 2008
# Description:
#   This function calculates the bank features portion of the physical
#   habitat metrics for National Lakes Assessment (NLA) data.  The function
#   requires a data frame containing validated physical habitat data collected
#   using the NLA protocol.
# Function Revisions:
#   10/21/08 cws: Corrected counts of missing parameters.  These are now zero.
#   11/06/08 cws: Removed code for changing NA counts to zero.
#   03/08/13 cws: Copied from 2007 study and renamed.
#   12/20/13 cws: Developed unit test for 2007 data and refactored metrics
#            function, updating column names and upcasing parameter names.
#            Using modalValues() instead of single use code.  Regression test
#            with 2007 data shows the following expected differences: 642 values
#            for 76 sites without BF data are absent instead of NA; 11 values of
#            BFFFLAT, BFFGRADUAL, BFFSTEEP, BFFVERTICAL, BFXHORIZDIST,
#            BFXVERTHEIGHT due to floating point truncation; and 13 values of
#            BFOANGLE due to reordering of multiple mode values for a total of
#            666 differences. Using protectedMean() to deter production of NaN
#            value for BFXVERTHEIGHT noted earlier in UID 6601 of the 2012
#            study. Included drawdown distances for 2012 processing.
#   12/23/13 cws: Completed unit test with 2013 data.  Standardized input data.
#            Regression test with 2007 data passes as described 12/20.
#   02/19/14 cws: Modified metsBankFeatures.fillinDistancesTest() to expect only
#            distance and drawdown related parameters in the returned dataframe.
#   06/12/14 tmk: Removed calls to the require() function.
# Arguments:
#   df = a data frame containing bank features data.  The data frame must
#     include columns that are named as follows:
#       UID - universal ID value, which uniquely identifies the site location, 
#             date of visit, visit order, habitat type, etc. for which metrics 
#             will be calculated.  For NLA, site ID, year and visit number are
#             used for this purpose.
#       STATION - the subordinate ID value, which identifies the location,
#               habitat type, order of occurence, etc. within a single UID.
#               For NLA, transect is used for this purpose.
#       PARAMETER - parameter name, which identifies the variables used in
#                   calculations. In wide data frame format, this argument
#                   would be used to name columns.  It is assumed that this
#                   argument has the following values: ANGLE, HORIZ_DIST,
#                   VERT_HEIGHT, HORIZ_DIST_DD, and VERT_HEIGHT_DD.
#       RESULT - parameter values, which are the values used in calculations.
#   data2007 = a logical value, which equals TRUE if 2007 data is being
#     processed.  The default value is FALSE.
# Output:
#   A data frame that contains the following columns:
#     UID - universal ID value
#     PARAMETER - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
################################################################################

  # Print initial messages
  cat('Bank Features calculations:\n')
  intermediateMessage('Bank Features mets', loc='start')

	stdData <- metsBankFeatures.standardizeData(df, data2007)

	angleMets <- metsBankFeatures.bankAngle(stdData)
	distanceMets <- metsBankFeatures.distances(stdData) 

  bfMets <- rbind(angleMets, distanceMets)
	
  intermediateMessage(' Done.', loc='end')

  return(bfMets)
}


metsBankFeatures.standardizeData <- function(df, data2007)
# returns dataframe with standardized input data.
# NEAR VERTICAL is from 2007 and NEAR_VERTICAL_UNDERCUT is from 2012.  These
# are standardized here (and should eventually be changed in the database)
## TODO Standardize ANGLE values in 2007 and 2012 NLA tables.
{
	rc <- within(df, RESULT <- ifelse(PARAMETER %in% c('ANGLE') & 
							          RESULT %in% c('NEAR VERTICAL','NEAR_VERTICAL_UNDERCUT')
					 				 ,'NEAR_VERTICAL'
						  			 ,RESULT
									 )
				)
				
	return(rc)
}


metsBankFeatures.bankAngle <- function(df)
# calculates bank angle metrics.  Returns dataframe
# with columns UID, PARAMETER, RESULT
{
	angles<-subset(df, PARAMETER=='ANGLE' & 
					   RESULT %in% c('FLAT','GRADUAL','STEEP','NEAR_VERTICAL')
				  )
	
	# mode of bank angle class
	modeAngle<-aggregate(list(RESULT=angles$RESULT)
						,list(UID=angles$UID)
						,modalValues, delim=', ', na.rm=TRUE
						)
	modeAngle$PARAMETER <- 'BFOANGLE'
	intermediateMessage('.1')
	
	
	# calculate fraction of lake with specific bank angles:
	flatAngle<-aggregate(list(RESULT=(angles$RESULT=='FLAT'))
						,list(UID=angles$UID)
						,protectedMean, na.rm=TRUE
						)
	flatAngle <- within(flatAngle
					   ,{PARAMETER <- 'BFFFLAT'
						 RESULT <- as.character(RESULT)
					 	}
					   )	
	
	gradualAngle<-aggregate(list(RESULT=(angles$RESULT=='GRADUAL'))
						   ,list(UID=angles$UID)
						   ,protectedMean, na.rm=TRUE
					 	   )
	gradualAngle <- within(gradualAngle
						  ,{PARAMETER <- 'BFFGRADUAL'
							RESULT <- as.character(RESULT)
						   }
						  )	
	
	steepAngle<-aggregate(list(RESULT=(angles$RESULT=='STEEP'))
						 ,list(UID=angles$UID)
						 ,protectedMean, na.rm=TRUE
						 )
	steepAngle$PARAMETER <- 'BFFSTEEP'
	steepAngle <- within(steepAngle
					   ,{PARAMETER <- 'BFFSTEEP'
						 RESULT <- as.character(RESULT)
						}
					   )	
	
	verticalAngle<-aggregate(list(RESULT=(angles$RESULT=='NEAR_VERTICAL'))
							,list(UID=angles$UID)
							,protectedMean, na.rm=TRUE
							)
	verticalAngle$PARAMETER <- 'BFFVERTICAL'
	verticalAngle <- within(verticalAngle
					   	   ,{PARAMETER <- 'BFFVERTICAL'
						   	 RESULT <- as.character(RESULT)
							}
					   	   )	
	
	
	# number of slopes recorded 
	nAngle<-aggregate(list(RESULT=I(angles$RESULT))
					 ,list(UID=angles$UID)
					 ,count
					 )
	nAngle$PARAMETER <- 'BFNANGLE'
	nAngle <- within(nAngle
					,{PARAMETER <- 'BFNANGLE'
					  RESULT <- as.character(RESULT)
					 }
					)	
	
	intermediateMessage('.2')

	rc <- rbind(modeAngle, flatAngle, gradualAngle, steepAngle, verticalAngle, nAngle)
	intermediateMessage('.3')
	
	return(rc)
}


metsBankFeatures.distances <- function(df)
# calculates metrics for horizontal distances and vertical heights.  
# Returns dataframe with columns UID, PARAMETER, RESULT.
{
	# Modify drawdown data based on assumptions. This is only meaningful if 
	# DRAWDOWN data is present, but that is (currently) handled inside the 
	# function.
	intermediateMessage('.4')
	df <- metsBankFeatures.fillinDistances(df)
	intermediateMessage('.5')
	
	
	# mean vertical and horizontal distances, and counts
	# Note: any conversion of results to numerics within subset()
	#   results in generation of warning messages about coercion 
	#   introducing NA results.
	tt <- subset(df, PARAMETER %in% c('VERT_HEIGHT','HORIZ_DIST', 'VERT_HEIGHT_DD','HORIZ_DIST_DD'))
	tt$RESULT <- as.numeric(tt$RESULT)
	
	meanDists<-aggregate(list(RESULT=tt$RESULT)
						,list(UID=tt$UID
							 ,PARAMETER=tt$PARAMETER
							 )
						,protectedMean, na.rm=TRUE
						)
	meanDists$PARAMETER <- with(meanDists
							   , ifelse(PARAMETER=='VERT_HEIGHT', 	'BFXVERTHEIGHT'
								,ifelse(PARAMETER=='HORIZ_DIST',  	'BFXHORIZDIST'
								,ifelse(PARAMETER=='VERT_HEIGHT_DD','BFXVERTHEIGHT_DD'
								,ifelse(PARAMETER=='HORIZ_DIST_DD', 'BFXHORIZDIST_DD', 'BFXUNKNOWN'
								 ))))
							   )
	
	
	nDists<-aggregate(list(RESULT=tt$RESULT)
					 ,list(UID=tt$UID
						  ,PARAMETER=tt$PARAMETER
						  )
					 ,count
					 )
	nDists$PARAMETER <- with(nDists
							, ifelse(PARAMETER=='VERT_HEIGHT', 'BFNVERTHEIGHT'
							 ,ifelse(PARAMETER=='HORIZ_DIST',  'BFNHORIZDIST'
							 ,ifelse(PARAMETER=='VERT_HEIGHT_DD','BFNVERTHEIGHT_DD'
							 ,ifelse(PARAMETER=='HORIZ_DIST_DD', 'BFNHORIZDIST_DD', 'BFNUNKNOWN'
							  ))))
			 )
	
	intermediateMessage('.6')
	
	rc <- rbind(meanDists, nDists)
}


metsBankFeatures.fillinDistances <- function(df)
# Used to fill in missing values of HORIZ_DIST_DD and VERT_HEIGHT_DD with zeros where
# it is safe to assume they are zero, i.e. when there is no drawdown noted.
#
# ARGUMENTS:
# df		dataframe with bank feature data.
#
# ASSUMPTIONS:
# PARAMETER values include at least one row of HORIZ_DIST_DD and VERT_HEIGHT_DD, otherwise
#   the expand.data.frame() call will not work.
# df has columns UID, STATION, PARAMETER, RESULT and none other.
#
{
	distances <- subset(df
					   ,PARAMETER %in% c('DRAWDOWN','HORIZ_DIST','VERT_HEIGHT','HORIZ_DIST_DD','VERT_HEIGHT_DD')
			   		   ,select=c(UID, STATION, PARAMETER, RESULT)
					   )
	
	# Make absent VERT_DIST_DD and HORIZ_DIST_DD values present in data with NA values.
	# This is done so they can be set to zero later.
	indivSites <- lapply(unique(distances$UID)
				 		,function(uid) {
							
							thisSite <- subset(distances, UID==uid)
									
							if('DRAWDOWN' %in% thisSite$PARAMETER) {
										
								# make sure 'HORIZ_DIST_DD','VERT_HEIGHT_DD' occur in this visit data
								tt <- rbind(thisSite
										   ,data.frame(UID=uid
							   						  ,STATION='DELETEME'
								  					  ,PARAMETER=c('HORIZ_DIST_DD','VERT_HEIGHT_DD')
								  					  ,RESULT=as.character(NA)
								  					  ,stringsAsFactors=FALSE
								  				  	  )
							   		   	   )
									
								# Add absent rows for this UID and then remove the rows 'seeded' above.
								rc <- subset(expand.data.frame(tt, c('UID','STATION','PARAMETER'))
											,STATION != 'DELETEME'
											)
													
							} else {
										
								# Change nothing as we can assume nothing without DRAWDOWN
								rc <- thisSite	
									
							}	
									
							return(rc)
						 }
						)
	dfExpanded <- do.call(rbind, indivSites)
										 
						 
	# Determine rows where missing distances can be assumed to be zero unless 
	# recorded as otherwise.
	correctableValues <- subset(distances, PARAMETER=='DRAWDOWN' & RESULT=='NO')
	
	
	# Change missing values to zero when DRAWDOWN is 'NO'. 
	dfFilledin <- within(dfExpanded
						,RESULT <- ifelse(paste(UID, STATION) %in% with(correctableValues, paste(UID, STATION))
										  & PARAMETER %in% c('HORIZ_DIST_DD','VERT_HEIGHT_DD')
										  & is.na(RESULT)
										 ,'0'
										 ,RESULT
										 )
						)
						
	
	return(dfFilledin)
}



# end of file
