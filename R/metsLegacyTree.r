metsLegacyTree <- function(invasivelegacy) {

################################################################################
# Function: metsLegacyTree
# Title: Calculate NRSA Legacy Riparian Trees Metrics
# Programmers: Suzanne San Romani
#              Curt Seeliger
#              Tom Kincaid
# Date: February 10, 2010
# Description:
#   This function calculates the legacy riparian trees portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires a data frame containing the invasive species/legacy
#   riparian trees data file.
# Metrics:
#   ltmxcnt - Legacy number of largest trees
#   ltmxdbh - Legacy largest tree dbh
#   ltmxdist - Legacy largest tree distance
#   ltmxht - Legacy largest tree height
#   ltmxsize - Legacy largest tree size class (SMLX)
#   ltmxspp - Legacy largest tree species
#   ltsplist - Legacy tree species list comma delim.
#   ltfracs - Legacy fraction of reach trees >= small
#   ltfracm - Legacy fraction of reach trees >= medium
#   ltfracl - Legacy fraction of reach trees >= large
#   ltfracx - Legacy fraction of reach trees >= Xlarge
#   ltmddist - Legacy mean dist of trees >= median size
#   ltmddom - Legacy dominant sp.
#   ltmddomn - Legacy dominant sp. Count
#   ltmdsub - Legacy subdominant sp. >= median size
#   ltmdsubn - Legacy subdominant sp. count
# Function Revisions:
#   02/10/10 ssr: Created.
#   02/18/10 cws: Removed source() of NRSAValidation.r.
#   03/22/10 cws: Added missing calls to checkEquals in unit test.
#   03/25/10 cws: Changed diff() calls to dfCompare().
#   09/16/10 cws: Removed hardcoding of NRSA database name, using NRSAdbName
#          instead.
#   01/24/11 cws: Removed source() of assignTaxCat() to NRSAvalidation.r.
#            Changed ltmxcnt, ltmxdbh, ltmxdist, ltmxht, ltmxsize to be max
#            values for trees with the largest sizen; formerly these values
#            were taken from whatever row was first in the subset of rows of
#            these largest trees (which relies on the accident of ordering
#            when there is more than one such tree at a site).  The value of
#            ltmxspp still relies on this ordering for now, until a better
#            definition comes along.  Until that time, this metric can vary
#            for each calculation.  Unit test updated to reflect this change,
#            as the old SAS mets were wrong.
#   02/11/11 cws: ltmxspp was misnamed ltmxdbh; now is fixed.  A bug in the unit
#            test prevented this from being seen.  Modified dataframe of
#            expected values for ltmxdbh at EPA01-0159.
#   07/31/12 tmk: Removed calls to the require() function.  Added argument tbl
#            to the function to identify name of the data file.  Added argument
#            NRSAdir to the function to identify the directory from which
#            metrics files are read and to which the output metrics file is
#            written.
#   12/20/12 tmk: Modified data input to use a data frame containing the data
#            file rather than a csv file.  Modified output to be a data frame
#            rather than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frame to
#            character variables.
#   01/24/13 cws: Changed use of reshape::cast to reshape2::dcast.  Requiring
#            reshape2 instead of reshape and calling dcast instead of cast; no
#            other changes made.
# Arguments:
#   invasivelegacy = a data frame containing the invasive species/legacy
#     riparian trees data file.  The data frame must include columns that are
#     named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   Note that possible values for variables in the input data frame are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   metsLegacyTree.1 - calculate metrics
################################################################################

# Print an initial message
  cat('Legacy Riparian Trees calculations:\n')

# Convert factors to character variables in the invasivelegacy data frame
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  invasivelegacy <- convert_to_char(invasivelegacy)

# Subset the invasivelegacy data frame to retain desired values in the column
# named PARAMETER and retain the set of desired columns
  intermediateMessage('.2 Subset the data frame.', loc='end')
  df1 <- subset(invasivelegacy, PARAMETER %in%
                c('TREE_TYP', 'SPECIES', 'DBH', 'HEIGHT', 'DISTANCE'), 
                select=c('UID', 'TRANSECT', 'PARAMETER', 'RESULT'))

# Calculate the metrics
  intermediateMessage('.3 Call function metsLegacyTree.1.', loc='end')
  mets <- metsLegacyTree.1(df1)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsLegacyTree.1 <- function(df1) {

##  Calculating metrics

##  Renaming PARAMETER and RESULT to variable and value
df1 <-rename(df1, c('PARAMETER', 'RESULT'), c('variable', 'value'))

# Casting (transforming) data using reshape2 package
lt <- dcast(df1, UID + TRANSECT ~ variable)
lt$DBH      <- as.character(lt$DBH)
#lt$NOT_VIS  <- as.character(lt$NOT_VIS)
lt$SPECIES  <- as.character(lt$SPECIES)
lt$TREE_TYP <- as.character(lt$TREE_TYP)
lt$HEIGHT   <- as.character(lt$HEIGHT)
lt$DISTANCE <- as.character(lt$DISTANCE)
lt$DISTANCE <- as.numeric(lt$DISTANCE)

lt$METRIC <- ''
lt$numdbh  <- NA 
lt$numht   <- NA 
lt$size    <- ''
lt$sizenum <- NA
lt$sizen   <- NA 

#  Creating values of DBH and HEIGHT with simpler codes
#  newDBH: 0-0.1 = 1; .1-.3 = 2; .3-.75 = 3; .75-2=4; >2=5
#  newHEIGHT: <5 = 1; 5-15 = 2; 15-30 = 3; >30 = 4
## Matrices for tree size
##
##  Determining sizen
##                        DBH
##              <5     5-15  15-30   >30
##   HEIGHT
##     0-0.1     1      2      3      4
##
##   0.1-0.3     2      3      4      5
##
##  0.3-0.75     3      4      5      6
##
##    0.75-2     4      5      6      7
##
##        >2     5      6      7      8
##
##
##  Determining size
##                        DBH
##              <5     5-15  15-30   >30
##   HEIGHT
##     0-0.1     S      S      M      M
##
##   0.1-0.3     S      M      M      M
##
##  0.3-0.75     M      M      L      L
##
##    0.75-2     L      L      L      X
##
##        >2     L      X      X      X
##

lt$numdbh <- ifelse(lt$DBH=='0-0.1', 1, lt$numdbh)
lt$numdbh <- ifelse(lt$DBH=='.1-.3', 2, lt$numdbh)
lt$numdbh <- ifelse(lt$DBH=='.3-.75', 3, lt$numdbh)
lt$numdbh <- ifelse(lt$DBH=='.75-2', 4, lt$numdbh)
lt$numdbh <- ifelse(lt$DBH=='>2', 5, lt$numdbh)

lt$numht <- ifelse(lt$HEIGHT=='<5', 1, lt$numht)
lt$numht <- ifelse(lt$HEIGHT=='5-15', 2, lt$numht)
lt$numht <- ifelse(lt$HEIGHT=='15-30', 3, lt$numht)
lt$numht <- ifelse(lt$HEIGHT=='>30', 4, lt$numht)

lt$size <- ifelse(lt$DBH=='0-0.1' & (lt$HEIGHT=='<5' | lt$HEIGHT=='5-15'), 'S', lt$size)
lt$size <- ifelse(lt$DBH=='.1-.3' & lt$HEIGHT=='<5', 'S', lt$size)
lt$size <- ifelse(lt$DBH=='0-0.1' & (lt$HEIGHT=='15-30' | lt$HEIGHT=='>30'), 'M', lt$size)
lt$size <- ifelse(lt$DBH=='.1-.3' & (lt$HEIGHT=='5-15' | lt$HEIGHT=='15-30' | lt$HEIGHT=='>30'), 'M', lt$size)
lt$size <- ifelse(lt$DBH=='.3-.75' & (lt$HEIGHT=='<5' | lt$HEIGHT=='5-15'), 'M', lt$size)
lt$size <- ifelse(lt$DBH=='.3-.75' & (lt$HEIGHT=='15-30' | lt$HEIGHT=='>30'), 'L', lt$size)
lt$size <- ifelse(lt$DBH=='.75-2' & (lt$HEIGHT=='<5' | lt$HEIGHT=='5-15' | lt$HEIGHT=='15-30'), 'L', lt$size)
lt$size <- ifelse(lt$DBH=='>2' & lt$HEIGHT=='5-15', 'L', lt$size)
lt$size <- ifelse(lt$DBH=='.75-2' & (lt$HEIGHT=='>30'), 'X', lt$size)
lt$size <- ifelse(lt$DBH=='>2' & (lt$HEIGHT=='5-15' | lt$HEIGHT=='15-30' | lt$HEIGHT=='>30'), 'X', lt$size)

lt$sizenum <- ifelse(lt$size=='S', 1, lt$sizenum)
lt$sizenum <- ifelse(lt$size=='M', 2, lt$sizenum)
lt$sizenum <- ifelse(lt$size=='L', 3, lt$sizenum)
lt$sizenum <- ifelse(lt$size=='X', 4, lt$sizenum)
 
lt$sizen <- ifelse(lt$DBH=='0-0.1' & lt$HEIGHT=='<5', 1, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='0-0.1' & lt$HEIGHT=='5-15')
                 | (lt$DBH=='.1-.3' & lt$HEIGHT=='<5'), 2, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='0-0.1' & lt$HEIGHT=='15-30')
                 | (lt$DBH=='.1-.3' & lt$HEIGHT=='5-15')
                 | (lt$DBH=='.3-.75' & lt$HEIGHT=='<5'), 3, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='0-0.1' & lt$HEIGHT=='>30')
                 | (lt$DBH=='.1-.3' & lt$HEIGHT=='15-30') 
                 | (lt$DBH=='.3-.75' & lt$HEIGHT=='5-15') 
                 | (lt$DBH=='.75-2' & lt$HEIGHT=='<5'), 4, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='.1-.3' & lt$HEIGHT=='>30')
                 | (lt$DBH=='.3-.75' & lt$HEIGHT=='15-30') 
                 | (lt$DBH=='.75-2' & lt$HEIGHT=='5-15') 
                 | (lt$DBH=='>2' & lt$HEIGHT=='<5'), 5, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='.3-.75' & lt$HEIGHT=='>30') 
                 | (lt$DBH=='.75-2' & lt$HEIGHT=='15-30') 
                 | (lt$DBH=='>2' & lt$HEIGHT=='5-15'), 6, lt$sizen)
lt$sizen <- ifelse((lt$DBH=='.75-2' & lt$HEIGHT=='>30')
                 | (lt$DBH=='>2' & lt$HEIGHT=='15-30'), 7, lt$sizen)
lt$sizen <- ifelse(lt$DBH=='>2' & lt$HEIGHT=='>30', 8, lt$sizen)

###  Assigning taxonomic category based on crew entry
lt <- assignTaxCat(lt)

###  Determining largest tree
#  Getting max of sizen
aa <- subset(lt, !(is.na(sizen)), select=c('UID','sizen'))
##  This is where the warnings occur if there are no non-missing arguments to max 
bb <- aggregate(list(maxSizen=aa$sizen), list(UID=aa$UID), max)
cc <- subset(merge(bb, lt), maxSizen==sizen)

skipthis<-function() { #####################################################
dd <- first(cc, 'UID', 'first.UID')
ee <- subset(dd, first.UID=='TRUE')


## NOTE:  Metrics for ltmxcnt procuced by SAS appear to count all trees
##        at a site, not just those with max sizen
# Getting counts of max sizen
ff <- aggregate(list(ltmxcnt=cc$sizen),list(UID=cc$UID),count)
gg <- merge(ee,ff)
ltMxMets <- rename(gg, c('DBH','HEIGHT','taxCat','size','DISTANCE'),
             c('ltmxdbh','ltmxht','ltmxspp','ltmxsize','ltmxdist'))
             
ltmxdbh  <- subset(ltMxMets, select=c('UID','METRIC','ltmxdbh'))
  ltmxdbh$METRIC <- 'ltmxdbh'
  ltmxdbh <- rename(ltmxdbh,'ltmxdbh','RESULT')
ltmxht  <- subset(ltMxMets, select=c('UID','METRIC','ltmxht'))             
  ltmxht$METRIC <- 'ltmxht'
  ltmxht <- rename(ltmxht,'ltmxht','RESULT')
ltmxspp  <- subset(ltMxMets, select=c('UID','METRIC','ltmxspp'))
  ltmxspp$METRIC <- 'ltmxspp'
  ltmxspp <- rename(ltmxspp,'ltmxspp','RESULT')
ltmxsize  <- subset(ltMxMets, select=c('UID','METRIC','ltmxsize'))
  ltmxsize$METRIC <- 'ltmxsize'
  ltmxsize <- rename(ltmxsize,'ltmxsize','RESULT')
ltmxdist  <- subset(ltMxMets, select=c('UID','METRIC','ltmxdist'))
  ltmxdist$METRIC <- 'ltmxdist'
  ltmxdist <- rename(ltmxdist,'ltmxdist','RESULT')
ltmxcnt  <- subset(ltMxMets, select=c('UID','METRIC','ltmxcnt'))
  ltmxcnt$METRIC <- 'ltmxcnt'
  ltmxcnt <- rename(ltmxcnt,'ltmxcnt','RESULT')
} ############################################################################

ltmxdbh  <- transform(aggregate(list(x=cc$numdbh), list(UID=cc$UID), max, na.rm=TRUE)
                     ,METRIC='ltmxdbh'
                     ,RESULT= ifelse(x==1, '0-0.1',
                              ifelse(x==2, '.1-.3',
                              ifelse(x==3, '.3-.75',
                              ifelse(x==4, '.75-2',
                              ifelse(x==5, '>2',    NA
                              )))))
                     ,x= NULL
                     ,stringsAsFactors=FALSE
                     )
ltmxht   <- transform(aggregate(list(x=cc$numht), list(UID=cc$UID), max, na.rm=TRUE)
                     ,METRIC='ltmxht'
                     ,RESULT= ifelse(x==1, '<5',
                              ifelse(x==2, '5-15',
                              ifelse(x==3, '15-30',
                              ifelse(x==4, '>30',   NA
                              ))))
                     ,x= NULL
                     ,stringsAsFactors=FALSE
                     )
ltmxsize <- transform(aggregate(list(x=cc$sizenum), list(UID=cc$UID), max, na.rm=TRUE)
                     ,METRIC='ltmxsize'
                     ,RESULT= ifelse(x==1, 'S',
                              ifelse(x==2, 'M',
                              ifelse(x==3, 'L',
                              ifelse(x==4, 'X',   NA
                              ))))
                     ,x= NULL
                     ,stringsAsFactors=FALSE
                     )
ltmxdist <- transform(aggregate(list(RESULT=cc$DISTANCE), list(UID=cc$UID)
                               ,function(x) {
                                    # max, or NA if largest trees have no distance
                                    if(all(is.na(x))) {
                                        return(NA)
                                    } else {
                                        return(max(x, na.rm=TRUE))
                                    }
                                }
                               )
                     ,METRIC='ltmxdist'
                     ,stringsAsFactors=FALSE
                     )
ltmxcnt <- transform(aggregate(list(RESULT=cc$sizen), list(UID=cc$UID), count)
                    ,METRIC='ltmxcnt'
                    ,stringsAsFactors=FALSE
                    )
ltmxspp <- transform(subset(first(cc, 'UID', 'first.UID')
                           ,first.UID==TRUE
                           ,select=c(UID,taxCat)
                           )
                    ,METRIC='ltmxspp'
                    ,RESULT=taxCat
                    ,taxCat=NULL
                    ,stringsAsFactors=FALSE
                    )

#### Determining median tree size and related metrics
# ltfracl - Legacy fraction of trees >= large
# ltfracm - Legacy fraction of trees >= medium
# ltfracs - Legacy fraction of trees >= small
# ltfracx - Legacy fraction of trees >= xlarge
# ltmddist - Legacy mean dist of trees >= median size

## NOTE:  SAS code used median DBH as median tree size.
## NOTE:  SAS code created counts for ltfracs, ltfracm, ltfracl, ltfracx.

## ltmddist
aa <- subset(aggregate(list(medianSize=lt$numdbh), list(UID=lt$UID),
             na.rm = T, median), !(is.na(medianSize)))
lt <- merge(lt, aa, all.x=T)
lt$medianDistance <- ifelse(lt$numdbh>=lt$medianSize, lt$DISTANCE, NA)
ltmddist <- aggregate(list(ltmddist=lt$medianDistance),
               list(UID=lt$UID,METRIC=lt$METRIC), mean, na.rm = T)
  ltmddist$METRIC <- 'ltmddist'
  ltmddist <- rename(ltmddist, 'ltmddist', 'RESULT')

## fractions of trees by size
# cntS - count of trees >= small -> s, m, l, x
# cntM - count of trees >= medium -> m, l, x
# cntL - count of trees >= large -> l, x
# cntX - count of trees >= xlarge  -> x

## Creating count of transects by UID
tranCnt <- subset(aggregate(list(tranCnt=lt$TRANSECT), by=list(UID=lt$UID), count), select=c('UID', 'tranCnt'))

sm <- aggregate(list(smCnt=subset(lt$size, lt$size %in% c('S','M','L','X'))),
        list(UID=subset(lt$UID,lt$size %in% c('S','M','L','X'))), count)
med <- aggregate(list(medCnt=subset(lt$size, lt$size %in% c('M','L','X'))),
        list(UID=subset(lt$UID,lt$size %in% c('M','L','X'))), count)
lg <- aggregate(list(lgCnt=subset(lt$size, lt$size %in% c('L','X'))),
        list(UID=subset(lt$UID,lt$size %in% c('L','X'))), count)
xl <- aggregate(list(xlCnt=subset(lt$size, lt$size %in% c('X'))),
        list(UID=subset(lt$UID,lt$size %in% c('X'))), count)

aa <- merge(sm, med, all=T)
bb <- merge(aa, lg, all=T)
cc <- merge(bb, xl, all=T)
treeCounts <- merge(tranCnt, cc, all=T)
treeCounts$ltfracs <- treeCounts$smCnt/treeCounts$tranCnt
treeCounts$ltfracm <- treeCounts$medCnt/treeCounts$tranCnt
treeCounts$ltfracl <- treeCounts$lgCnt/treeCounts$tranCnt
treeCounts$ltfracx <- treeCounts$xlCnt/treeCounts$tranCnt

treeCounts$ltfracs <- ifelse(is.na(treeCounts$ltfracs), 0, treeCounts$ltfracs)
treeCounts$ltfracm <- ifelse(is.na(treeCounts$ltfracm), 0, treeCounts$ltfracm)
treeCounts$ltfracl <- ifelse(is.na(treeCounts$ltfracl), 0, treeCounts$ltfracl)
treeCounts$ltfracx <- ifelse(is.na(treeCounts$ltfracx), 0, treeCounts$ltfracx)

treeCounts$METRIC <- ''

ltfracs <- subset(treeCounts, select=c('UID','METRIC','ltfracs'))
  ltfracs$METRIC <- 'ltfracs'
  ltfracs <- rename(ltfracs,'ltfracs','RESULT')
ltfracm <- subset(treeCounts, select=c('UID','METRIC','ltfracm'))
  ltfracm$METRIC <- 'ltfracm'
  ltfracm <- rename(ltfracm,'ltfracm','RESULT')
ltfracl <- subset(treeCounts, select=c('UID','METRIC','ltfracl'))
  ltfracl$METRIC <- 'ltfracl'
  ltfracl <- rename(ltfracl,'ltfracl','RESULT')
ltfracx <- subset(treeCounts, select=c('UID','METRIC','ltfracx'))
  ltfracx$METRIC <- 'ltfracx'
  ltfracx <- rename(ltfracx,'ltfracx','RESULT')

### And now for the piece de resistance - the list of dominant and subdominant species
# ltsplist - List of all speicies present
# ltmddom - Species occurring most commonly
# ltmddomn - Number of times dominant speices occurs
# ltmdsub - Second most commonly occurring species
# ltmdsubn - Number of tims subdominant species occurs

## NOTE:  SAS code miscounts ltmddomn and ltmdsubn by one tree in each metric.
                     
##  Creating ltmddom and ltmdsub
counts <- aggregate(list(count=lt$taxCat), list('UID'=lt$UID,'METRIC'=lt$METRIC, 'maxTaxCat'=lt$taxCat), count)
ltmddomn <- aggregate(list('ltmddomn'=counts$count), list('UID'=counts$UID, METRIC=counts$METRIC), max)
  ltmddomn$METRIC <- 'ltmddomn'
  ltmddomn <- rename(ltmddomn,'ltmddomn','RESULT')
  
aa <- subset(merge(counts, subset(ltmddomn,select=c('UID','RESULT')), by='UID'), count==RESULT)
ltmddom <- aggregate(list('ltmddom'=aa$maxTaxCat)
                        ,list('UID'=aa$UID,'METRIC'=aa$METRIC)
                        ,function(x) { paste(x, collapse=',') } )
  ltmddom$METRIC <- 'ltmddom'
  ltmddom <- rename(ltmddom,'ltmddom','RESULT')
                     
bb <- subset(merge(counts, subset(ltmddomn, select=c('UID','RESULT')),
        by='UID'), count!=RESULT, select=c('UID','METRIC','maxTaxCat','count'))                      
ltmdsubn <- aggregate(list('ltmdsubn'=bb$count), list('UID'=bb$UID, METRIC=bb$METRIC), max)
  ltmdsubn$METRIC <- 'ltmdsubn'
  ltmdsubn <- rename(ltmdsubn,'ltmdsubn','RESULT')
cc <- subset(merge(counts, subset(ltmdsubn,select=c('UID','RESULT')), by='UID'), count==RESULT)
ltmdsub <- aggregate(list('ltmdsub'=cc$maxTaxCat)
                        ,list('UID'=cc$UID,'METRIC'=cc$METRIC)
                        ,function(x) { paste(x, collapse=',')})
  ltmdsub$METRIC <- 'ltmdsub'
  ltmdsub <- rename(ltmdsub,'ltmdsub','RESULT')

##  List of all trees
hasTrees <- subset(lt, !(is.na(SPECIES)))                   
ltsplist <- aggregate(list('ltsplist'=hasTrees$SPECIES)
                        ,list('UID'=hasTrees$UID,'METRIC'=hasTrees$METRIC) 
                        ,function(x) { paste(x, collapse=',')})
  ltsplist$METRIC <- 'ltsplist'
  ltsplist <- rename(ltsplist,'ltsplist','RESULT')


####  Woo hoo! Let's rbind these puppies and put 'em to bed
mhtrees <- rbind(ltmxdbh,ltmxht,ltmxspp,ltmxsize,ltmxdist,ltmxcnt,ltfracs,ltfracm,
                 ltfracl,ltfracx,ltmddist,ltsplist,ltmddom,ltmddomn,ltmdsub,
                 ltmdsubn)

}



# end of file
