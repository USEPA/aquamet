metsChannelHabitat <- function(thalweg) {

################################################################################
# Function: metsChannelHabitat
# Title: Calculate NRSA Channel Habitat Metrics
# Programmers: Randy Hjort
#              Curt Seeliger
#              Suzanne San Romani
#              Tom Kincaid
# Date: January 4, 2010
# Description:
#   This function calculates the channel habitat portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires a data frame containing the thalweg data file.
# Function Revisions:
#   01/04/10 rch: Copied, plagerized and made up this code.
#   02/18/10 cws: Removed source() of NRSAValidation.r, NA_filler.r and
#            summaryby.r.
#   03/23/10 ssr: Moved creation of unit test dataframes to separate functions.
#   06/03/10 cws: Removed pct_sb from calculations.  Is not legal channel unit
#            code, and does not occur in the 2008-2009 field data, and it
#            collides with the substrate metric pct_sb.
#   09/16/10 cws: Removed hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   11/02/10 cws: Modified to handle single-protocol datasets without choking.
#            Also re-prettyprinting.  Modified unit test to test single-protocol
#            calculations.
#   08/03/12 tmk: Removed calls to the require() function.  Removed use of ODBC
#            data connection and replaced with data input from csv files using a
#            call to function read.csv.  Added argument tbl to the function to
#            identify name of the data file.  Added argument NRSAdir to the
#            function to identify the directory from which the data file is read
#            and to which the output metrics file is written.
#   12/20/12 tmk: Modified data input to use a data frame containing the data
#            file rather than a csv file.  Modified output to be a data frame
#            rather than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frame to
#            character variables.
# Arguments:
#   thalweg = a data frame containing the thalweg data file.  The data frame
#     must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       STATION - station number along thalweg between transects
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   Note that possible values for variables in the input data frame are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   metsChannelHabitat.1 - calculate metrics
################################################################################

# Print an initial message
  cat('Channel Habitat calculations:\n')

# Convert factors to character variables in the thalweg data frame
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  thalweg <- convert_to_char(thalweg)

# Calculate the metrics
  intermediateMessage('.2 Call function metsChannelHabitat.1.', loc='end')
  mets <- metsChannelHabitat.1(thalweg)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsChannelHabitat.1 <- function(indat) {

# Does all the real work for metsChannelHabitat.
# Returns a dataframe of calculations if successful
# or a character string describing the problem if
# one was encountered.
#
# ARGUMENTS:
# indat		dataframe of channel data.
# protocols	dataframe relating UID to the
#			  sampling protocol used at the site.
#

  intermediateMessage('Channel Habitat mets', loc='start')
   
  cdData <- subset(indat
                  ,PARAMETER == 'CHANUNCD' &
                   ((RESULT %in% c('FA','CA','RA','RI','GL','PB','PP','PD','PL'
                                  ,'PT','P','DR','SB'
                                  )
                     &
                     SAMPLE_TYPE == 'PHAB_THALW'
                    )
                    |
                    (RESULT %in% c('FA','RA','RI','GL','PO','CA','DR')
                     &
                     SAMPLE_TYPE == 'PHAB_THAL'
                    )
                   ) &
                   TRANSECT %in% LETTERS[1:11]
                  )

  intermediateMessage('.1')

  # Metrics common to both wadeable and boatable protocols
  tgl <- summaryby(cdData,'count',"pct_gl")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='GL',na.rm=TRUE)})
  tgl<-merge(tgl,tyout,by='UID',all.x=TRUE)
  #tgl$typesum<- ifelse( is.na(tgl$yessum),0,tgl$yessum)
  tgl$RESULT <- (tgl$typesum/tgl$RESULT)*100
  tgl<-tgl[c('UID','METRIC','RESULT')]

  tri <- summaryby(cdData,'count',"pct_ri")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='RI',na.rm=TRUE)})
  tri<-merge(tri,tyout,by='UID',all.x=TRUE)
  #tri$typesum<- ifelse( is.na(tri$yessum),0,tri$yessum)
  tri$RESULT <- (tri$typesum/tri$RESULT)*100
  tri<-tri[c('UID','METRIC','RESULT')]

  tra <- summaryby(cdData,'count',"pct_ra")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='RA',na.rm=TRUE)})
  tra<-merge(tra,tyout,by='UID',all.x=TRUE)
  #tra$typesum<- ifelse( is.na(tra$yessum),0,tra$yessum)
  tra$RESULT <- (tra$typesum/tra$RESULT)*100
  tra<-tra[c('UID','METRIC','RESULT')]

  tca <- summaryby(cdData,'count',"pct_ca")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='CA',na.rm=TRUE)})
  tca<-merge(tca,tyout,by='UID',all.x=TRUE)
  #tca$typesum<- ifelse( is.na(tca$yessum),0,tca$yessum)
  tca$RESULT <- (tca$typesum/tca$RESULT)*100
  tca<-tca[c('UID','METRIC','RESULT')]

  tfa <- summaryby(cdData,'count',"pct_fa")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='FA',na.rm=TRUE)})
  tfa<-merge(tfa,tyout,by='UID',all.x=TRUE)
  #tfa$typesum<- ifelse( is.na(tfa$yessum),0,tfa$yessum)
  tfa$RESULT <- (tfa$typesum/tfa$RESULT)*100
  tfa<-tfa[c('UID','METRIC','RESULT')]

  tdr <- summaryby(cdData,'count',"pct_dr")
  tyout<-aggregate( list(typesum=cdData$RESULT),list(UID=cdData$UID),function(x){sum(x=='DR',na.rm=TRUE)})
  tdr<-merge(tdr,tyout,by='UID',all.x=TRUE)
  #tdr$typesum<- ifelse( is.na(tdr$yessum),0,tdr$yessum)
  tdr$RESULT <- (tdr$typesum/tdr$RESULT)*100
  tdr<-tdr[c('UID','METRIC','RESULT')]

  intermediateMessage('.2')
  
  # Boatable-only protocol metric
  btdata  <- subset(cdData,SAMPLE_TYPE == 'PHAB_THAL')
  if(nrow(btdata)>0) {
      tpo <- summaryby(btdata,'count',"pct_po")
      tyout<-aggregate( list(typesum=btdata$RESULT),list(UID=btdata$UID),function(x){sum(x=='PO',na.rm=TRUE)})
      tpo<-merge(tpo,tyout,by='UID',all.x=TRUE)
      #tpo$typesum<- ifelse( is.na(tpo$yessum),0,tpo$yessum)
      tpo$RESULT <- (tpo$typesum/tpo$RESULT)*100
      tpo<-tpo[c('UID','METRIC','RESULT')]
  }
  intermediateMessage('.3')

  #subset data for wadeable  only RESULT values

  intermediateMessage('.4')
  wddata  <- subset(cdData,SAMPLE_TYPE == 'PHAB_THALW')
  if(nrow(wddata)>0) {
      tpp <- summaryby(wddata,'count',"pct_pp")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='PP',na.rm=TRUE)})
      tpp<-merge(tpp,tyout,by='UID',all.x=TRUE)
      #tpp$typesum<- ifelse( is.na(tpp$yessum),0,tpp$yessum)
      tpp$RESULT <- (tpp$typesum/tpp$RESULT)*100
      tpp<-tpp[c('UID','METRIC','RESULT')]

      tpd <- summaryby(wddata,'count',"pct_pd")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='PD',na.rm=TRUE)})
      tpd<-merge(tpd,tyout,by='UID',all.x=TRUE)
      #tpd$typesum<- ifelse( is.na(tpd$yessum),0,tpd$yessum)
      tpd$RESULT <- (tpd$typesum/tpd$RESULT)*100
      tpd<-tpd[c('UID','METRIC','RESULT')]

      tpb <- summaryby(wddata,'count',"pct_pb")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='PB',na.rm=TRUE)})
      tpb<-merge(tpb,tyout,by='UID',all.x=TRUE)
      #tpb$typesum<- ifelse( is.na(tpb$yessum),0,tpb$yessum)
      tpb$RESULT <- (tpb$typesum/tpb$RESULT)*100
      tpb<-tpb[c('UID','METRIC','RESULT')]


      tpl <- summaryby(wddata,'count',"pct_pl")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='PL',na.rm=TRUE)})
      tpl<-merge(tpl,tyout,by='UID',all.x=TRUE)
      #tpl$typesum<- ifelse( is.na(tpl$yessum),0,tpl$yessum)
      tpl$RESULT <- (tpl$typesum/tpl$RESULT)*100
      tpl<-tpl[c('UID','METRIC','RESULT')]


      tpt <- summaryby(wddata,'count',"pct_pt")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='PT',na.rm=TRUE)})
      tpt<-merge(tpt,tyout,by='UID',all.x=TRUE)
      #tpt$typesum<- ifelse( is.na(tpt$yessum),0,tpt$yessum)
      tpt$RESULT <- (tpt$typesum/tpt$RESULT)*100
      tpt<-tpt[c('UID','METRIC','RESULT')]

      tp <- summaryby(wddata,'count',"pct_p")
      tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='P',na.rm=TRUE)})
      tp<-merge(tp,tyout,by='UID',all.x=TRUE)
      #tp$typesum<- ifelse( is.na(tp$yessum),0,tp$yessum)
      tp$RESULT <- (tp$typesum/tp$RESULT)*100
      tp<-tp[c('UID','METRIC','RESULT')]

#               tsb <- summaryby(wddata,'count',"pct_sb")
#               tyout<-aggregate( list(typesum=wddata$RESULT),list(UID=wddata$UID),function(x){sum(x=='SB',na.rm=TRUE)})
#               tsb<-merge(tsb,tyout,by='UID',all.x=TRUE)
#               #tsb$typesum<- ifelse( is.na(tsb$yessum),0,tsb$yessum)
#               tsb$RESULT <- (tsb$typesum/tsb$RESULT)*100
#               tsb<-tsb[c('UID','METRIC','RESULT')]

  }
  intermediateMessage('.5')

  #compute summed metrics

  pfast<-rbind(tfa,tca,tra,tri)
  tfast<-summaryby(pfast,'sum','pct_fast')


  wSlow <- NULL
  wPool <- NULL
  wmets <- NULL
  if (nrow(wddata)>0) {
      wSlow <- rbind(tpp,tpd,tpb,tpl,tpt,tp)
      wPool <- rbind(tpp,tpd,tpb,tpl,tpt,tp)
      wmets <- rbind(tpp,tpd,tpb,tpl,tpt,tp)
  }
  bSlow <- NULL
  bPool <- NULL
  bmets <- NULL
  if (nrow(btdata)>0) {
      bSlow <- tpo
      bPool <- tpo
      bmets <- tpo
  }

#  pslow <- rbind(tpp,tpd,tpb,tpl,tpt,tp,tgl,tpo)
  pslow <- rbind(wSlow,bSlow,tgl)
  tslow <- summaryby(pslow,'sum','pct_slow')

#  ppool <- rbind(tpp,tpd,tpb,tpl,tpt,tp,tpo)
  ppool <- rbind(wPool,bPool)
  tpool <- summaryby(ppool,'sum','pct_pool')

  intermediateMessage('.6')
#  mets <- rbind(tdr,tp,tpt,tpl,tpb,tpd,tpp,tgl,tri,tra,tca,tfa,tfast,tslow,tpool)
  mets <- rbind(tgl,tri,tra,tca,tfa,tdr,wmets,tfast,tslow,tpool)

  intermediateMessage('.  Done.', loc='end')
   
  return(mets)
    
}



# end of file
