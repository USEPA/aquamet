metsInvasiveSpecies <- function(invasivelegacy) {

################################################################################
# Function: metsInvasiveSpecies
# Title: Calculate NRSA Invasive Species Metrics
# Programmers: Suzanne San Romani
#              Curt Seeliger
#              Tom Kincaid
# Date: February 10, 2010
# Description:
#   This function calculates the invasive species portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires a data frame containing the invasive species/legacy
#   riparian trees data file.
# Metrics:
#   f_myrspi = count of E_WTRMILF/count of transects
#   f_hydver = count of HYDRILLA/count of transects
#   f_eiccra = count of W_HYACINTH/count of transects
#   f_nympel = count of YLW_FLTHEAR/count of transects
#   f_lytsal = count of P_LSTRIFE/count of transects
#   f_arudon = count of G_REED/count of transects
#   f_butumb = count of FLWR_RUSH/count of transects
#   f_tamspp = count of SALT_CED/count of transects
#   f_rosmul = count of MF_ROSE/count of transects
#   f_eupesu = count of SPURGE/count of transects
#   f_none = count of NO_INVASIVES/count of transects
#   ip_count = sum(f_myrspi, f_hydver, f_eiccra, f_nympel, f_lytsal, f_arudon,
#                  f_butumb, f_tamspp, f_rosmul, f_eupesu)
# Function Revisions:
#   02/10/10 ssr: Created.
#   03/23/10 cws: Moved creation of test dataframes into separate functions.
#   03/25/10 cws: Changed diff() calls to dfCompare().
#   06/24/10 cws: Modified to handle odd case when transect has NO_INVASIVES
#            marked as well as an invasive species marked.  This shouldn't,
#            in the hopeful sense, make it through QA but we can assume a
#            species marked as present actually is present and safely ignore
#            the NO_INVASIVES check in these cases.
#   09/16/10 cws: Removing hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   11/02/10 cws: Modified to handle datasets with no NO_INVASIVES boxes
#            checked.  Updated unit test to check for this case.
#   07/26/12 tmk: Removed use of ODBC data connection and replaced with data
#            input from csv files using a call to function read.csv.  Added
#            argument tbl to the function to identify name of the data file.
#            Added argument NRSAdir to the function to identify the directory
#            from which the data file is read and to which the output metrics
#            file is written.
#   12/20/12 tmk: Modified data input to use a data frame containing the data
#            file rather than a csv file.  Modified output to be a data frame
#            rather than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frame to
#            character variables.
# Arguments:
#   invasivelegacy = a data frame containing the invasive species/legacy
#     riparian trees data file.  The data frame must include columns that are
#     named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   Note that possible values for variables in the input data frame are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   metsInvasiveSpecies.1 - calculate metrics
################################################################################

# Print an initial message
  cat('Invasive Species calculations:\n')

# Convert factors to character variables in the invasivelegacy data frame
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  invasivelegacy <- convert_to_char(invasivelegacy)

# Subset the invasivelegacy data frame to retain desired values in the column
# named PARAMETER and retain the set of desired columns
  intermediateMessage('.2 Subset the data frame.', loc='end')
  df <- subset(invasivelegacy, PARAMETER %in%
               c('E_WTRMILF', 'HYDRILLA', 'W_HYACINTH', 'YLW_FLTHEAR',
                 'P_LSTRIFE', 'G_REED', 'FLWR_RUSH', 'SALT_CED', 'MF_ROSE',
                 'SPURGE', 'NO_INVASIVES'),
               select=c('UID', 'TRANSECT', 'PARAMETER', 'RESULT'))

#  Calculate the metrics
  intermediateMessage('.3 Call function metsInvasiveSpecies.1.', loc='end')
  mets <- metsInvasiveSpecies.1(df)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsInvasiveSpecies.1 <- function(df) {

df$RESULT <- ifelse(df$RESULT=='X' | df$RESULT == 'Y', 1, df$RESULT)              
#   Creating counts of individual invasive species
aa <- ddply(df,c('UID','PARAMETER'),summarise,METRIC=unique(PARAMETER),RESULT=length(na.omit(RESULT)))
aa$PARAMETER <- NULL
# aa <- aggregate(list(RESULT=df$RESULT), by=list(UID=df$UID, METRIC=df$PARAMETER), count)

##Creating count of transects observed
bb <- subset(df, select=c('UID', 'TRANSECT'))
cc <- bb[!duplicated(bb),]
dd <- ddply(cc,c('UID'),summarise,tranCount=length(na.omit(TRANSECT)))
# dd <- aggregate(list(tranCount=cc$TRANSECT), list(UID=cc$UID), count)
ee <- merge(aa,dd)

#    Creating metrics for individual species
#   Because individual counts are not kept with the calculated metrics,
#   we are changing the species name to the species metric name
ee$METRIC <- ifelse(ee$METRIC=='E_WTRMILF', 'f_myrspi', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='HYDRILLA', 'f_hydver', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='W_HYACINTH', 'f_eiccra', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='YLW_FLTHEAR', 'f_nympel', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='P_LSTRIFE', 'f_lytsal', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='G_REED', 'f_arudon', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='FLWR_RUSH', 'f_butumb', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='SALT_CED', 'f_tamspp', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='MF_ROSE', 'f_rosmul', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='SPURGE', 'f_eupesu', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='NO_INVASIVES', 'f_none', ee$METRIC)
#   All invasive species metrics are number of observations within a site
#   divided by the number of transects observed during site visit
ee$RESULT <- ee$RESULT/ee$tranCount
#   Done with count of transects, deleting it
ee$tranCount <- NULL

#   Calculating ip_score, which is the sum of all metrics of invasive species
#   present.
ff <- ddply(subset(ee,METRIC!='f_none'),c('UID'),summarise,METRIC='ip_score',RESULT=sum(RESULT))
# ff <- aggregate(list(RESULT=ee[ee$METRIC != 'f_none',]$RESULT),
#                      list(UID=ee[ee$METRIC != 'f_none',]$UID), sum)
# ff$METRIC <- 'ip_score'
# ff <- ff[,c('UID','METRIC','RESULT')]

#   If there are no invasive species present, it will not have been calculated
#   in the previous step, none must equal 1, and therefore ip_score must equal 0.
#   This does not take into account transects in which NO_INVASIVES were checked
#   along with an invasive.  This *should* be caught during QA, but if it isn't
#   we'll assume the invasive actually exists and ignore the NO_INVASIVES flag.
gg <- subset(ee, METRIC=='f_none' & RESULT == 1)
if(nrow(gg)==0) {
    gg <- NULL
} else {
    gg$METRIC <- 'ip_score'
    gg$RESULT <- 0
    gg <- subset(gg, !(UID %in% ff$UID))
}

#    Creating final file -- indivual species metrics, ip_score when invasive
#   species are present, and ip_score when no invasive species are present.
mhinplnt <- rbind(ee,ff,gg)
}



# end of file
