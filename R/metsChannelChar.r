metsChannelChar <- function(bankgeometry, channelchar) {
  
################################################################################
# Function: metsChannelChar
# Title: Calculate NRSA Channel Characteristic Metrics
# Programmers: Randy Hjort
#              Curt Seeliger
#              Suzanne San Romani
#              Tom Kincaid
# Date: January 27, 2010
# Description:
#   This function calculates the channel characteristics portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires data frames containing the bank geometry and  channel
#   characteristics data files.
# Metrics:
#   xshor2vg, mxshor, mnshor, pct_ovrb, pctch_b, pctch_c, pctch_n, pctch_u and
#   conbankfull, confeatures, conpattern, conpercent, constraint, convalley,
#   convalleybox
# Function Revisions:
#   01/27/10 rch: copied, plagerized and made up this code.
#   02/18/10 cws: removed source() of NRSAValidation.r and summaryby.r
#   03/23/10 ssr: moved creation of unit test dataframes to separate functions.
#   06/10/10 cws: removed list of created metrics as incorrect.
#   06/24/10 cws: Added mets from tblChannelChar2
#   09/16/10 cws: Removing hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   11/04/10 cws: Modified to handle single-protocol data, updated unit test
#            accordingly.
#   11/18/10 cws: added require(Hmisc) for %nin% operator
#   07/26/12 tmk: Removed calls to the require() function.  Removed use of ODBC
#            data connection and replaced with data input from csv files using a
#            call to function read.csv.  Added argument tbl to the function to
#            identify the names of the data files.  Added argument NRSAdir to
#            the function to identify the directory from which the data file is
#            read and to which the output metrics file is written.
#   12/20/12 tmk: Modified data input to use data frames containing data files
#            rather than csv files.  Modified output to be a data frame rather
#            than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frames to
#            character variables.
# Arguments:
#   bankgeometry = a data frame containing the bank geometry data file.  The
#     data frame must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       TRANSDIR - transverse location along transect
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       FLAG - flag
#   channelchar = a data frame containing the channel characteristics data file.
#     The data frame must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       FLAG - flag
#   Note that possible values for variables in the input data frames are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   metsChannelChar.1 - calculate metrics
################################################################################


# Print an initial message
  cat('Channel Characteristic calculations:\n')

# Convert factors to character variables in the input data frames
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  bankgeometry <- convert_to_char(bankgeometry)
  channelchar <- convert_to_char(channelchar)

# Calculate the metrics
  intermediateMessage('.2 Call function metsChannelChar.1.', loc='end')
  mets <- metsChannelChar.1(bankgeometry, channelchar)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsChannelChar.1 <- function(indat, chanCon) {
# Does all the real work for metsChannelChar.
# Returns a dataframe of calculations if successful
# or a character string describing the problem if
# one was encountered.
#
# ARGUMENTS:
# indat		dataframe of bank geometry data taken at each transect.
# cc        dataframe with channel characteristics data taken for entire site.
# protocols	dataframe relating UID to the
#			  sampling protocol used at the site.
#

  intermediateMessage('Channel Characteristic mets', loc='start')

  #cdData <- subset(indat,PARAMETER %in% c('CONSTRT','SHOR2RIP','SEEOVRBK'))
  # cdData <- merge(cdData, protocols, by='UID', all.x=TRUE, all.y=FALSE)

  #Create datasets needed for the calculations
  cdata <- subset(indat,SAMPLE_TYPE =='PHAB_CHANB' & PARAMETER =='CONSTRT' )
  rdata <- subset(indat,SAMPLE_TYPE =='PHAB_CHANB' & PARAMETER =='SHOR2RIP' )
  rdata$RESULT<-as.numeric( rdata$RESULT)
  odata <- subset(indat,SAMPLE_TYPE =='PHAB_CHANB' & PARAMETER =='SEEOVRBK' )

  mets <- NULL   # Assemble calculations here.
  if(nrow(rdata)>0) {
      #Use summaryby for the three metrics of shor2rip distance (boatable only)
      xsh <- summaryby(rdata,'mean',"xshor2vg")
      mxs <- summaryby(rdata,'max',"mxshor")
      mns <- summaryby(rdata,'min',"mnshor")
      mets <- rbind(xsh, mxs, mns)
      intermediateMessage('.1')
  }
  
  if(nrow(odata)>0) {
      #Calculate percentages for each of the pct_* metrics and format the results (boatable only)
 
      tco <- summaryby(odata,'count',"pct_ovrb")
      tyout<-aggregate( list(yessum=odata$RESULT),list(UID=odata$UID),function(x){sum(x=='YES',na.rm=TRUE)})
      tco<-merge(tco,tyout,by='UID',all.x=TRUE)
      tco$yessum<- ifelse( is.na(tco$yessum),0,tco$yessum)
      tco$RESULT <- (tco$yessum/tco$RESULT)*100
      tco<-tco[c('UID','METRIC','RESULT')]
      mets <- rbind(mets, tco)
      intermediateMessage('.2')
  }
  
  if(nrow(cdata)>0) {
      tbb <- summaryby(cdata,'count',"pctch_b")
      bb<-aggregate(list(letsum=cdata$RESULT),list(UID=cdata$UID),function(x){sum(x=='B',na.rm=TRUE)})
      tbb<-merge(tbb,bb,by='UID',all.x=TRUE)
      tbb$RESULT <- (tbb$letsum/tbb$RESULT)*100
      tbb<-tbb[c('UID','METRIC','RESULT')]

      tcc <- summaryby(cdata,'count',"pctch_c")
      cc<-aggregate(list(letsum=cdata$RESULT),list(UID=cdata$UID),function(x){sum(x=='C',na.rm=TRUE)})
      tcc<-merge(tcc,cc,by='UID',all.x=TRUE)
      tcc$RESULT <- (tcc$letsum/tcc$RESULT)*100
      tcc<-tcc[c('UID','METRIC','RESULT')]

      tnn <- summaryby(cdata,'count',"pctch_n")
      nn<-aggregate(list(letsum=cdata$RESULT),list(UID=cdata$UID),function(x){sum(x=='N',na.rm=TRUE)})
      tnn<-merge(tnn,nn,by='UID',all.x=TRUE)
      tnn$RESULT <- (tnn$letsum/tnn$RESULT)*100
      tnn<-tnn[c('UID','METRIC','RESULT')]

      tuu <- summaryby(cdata,'count',"pctch_u")
      uu<-aggregate(list(letsum=cdata$RESULT),list(UID=cdata$UID),function(x){sum(x=='U',na.rm=TRUE)})
      tuu<-merge(tuu,uu,by='UID',all.x=TRUE)
      tuu$RESULT <- (tuu$letsum/tuu$RESULT)*100
      tuu<-tuu[c('UID','METRIC','RESULT')]

      mets <- rbind(mets, tbb, tcc, tnn, tuu)

      intermediateMessage('.3')
  }
  
  if(nrow(chanCon)>0) {
      # Translate channel characteristics taken for entire site (boatable only)
      ccMets <- rename(chanCon[c('UID','PARAMETER','RESULT')], 'PARAMETER', 'METRIC')
      ccMets$METRIC <- ifelse(ccMets$METRIC=='BANKFULL', 'conbankfull'
                      ,ifelse(ccMets$METRIC=='CONSTRNT', 'constraint'
                      ,ifelse(ccMets$METRIC=='FEATURES', 'confeatures'
                      ,ifelse(ccMets$METRIC=='PATTERN', 'conpattern'
                      ,ifelse(ccMets$METRIC=='PERCENT', 'conpercent'
                      ,ifelse(ccMets$METRIC=='VALLEY', 'convalley'
                      ,ifelse(ccMets$METRIC=='VALLYBOX', 'convalleybox','UNKNOWN!!'
                      )))))))

      mets <- rbind(mets, ccMets)
      intermediateMessage('.4')
  }
  
  #add the datasets together and return
 intermediateMessage('.  Done.', loc='end')

  return(mets)

}



# end of file
