metsAquaticMacrophytes <- function(df) {

################################################################################
# Function: metsAquaticMacrophytes
# Title: Calculate NLA Aquatic Macrophyte Metrics
# Programmers: Curt Seeliger
#              Tom Kincaid
# Date: October 14, 2008
# Description:
#   This function calculates the aquatic macrophyte portion of the physical
#   habitat metrics for National Lakes Assessment (NLA) data.  The function
#   requires a data frame containing validated physical habitat data collected
#   using the NLA protocol.
# Function Revisions:
#   10/14/08 cws: Cover values normalized at each station/subid prior to metrics
#            calculation.
#   10/20/08 cws: Removed normalization, as individual AM categories are 
#            independent.
#   03/08/13 cws: Copied from 2007 study and renamed.
#   12/24/13 cws: Developed unit test for 2007 data and refactored metrics
#            function, updating column names and upcasing parameter names.
#            Using modalValues() instead of single use code.  Regression test
#            with 2007 data shows the following expected differences: 1103 NA
#            and 0 values for 57 sites which have no AM data and 2 more sites
#            with only AM_EMERGENT and AM_FLOATING data; 145 values which differ
#            due to floating point issues.  No separate unit check using 2012
#            data was created because the data has not changed.  Refactored
#            metrics code. Regression test with 2007 passes but differently than
#            described above: 1103 NA and 0 values absent as above, but only one
#            difference due to floating point issues, AMVFLOATING at 8465.
#   06/12/14 tmk: Removed calls to the require() function.
# Arguments:
#   df = a data frame containing aquatic macrophyte data.  The data frame must
#     include columns that are named as follows:
#       UID - universal ID value, which uniquely identifies the site location, 
#             date of visit, visit order, habitat type, etc. for which metrics 
#             will be calculated.  For NLA, site ID, year and visit number are
#             used for this purpose.
#       STATION - the subordinate ID value, which identifies the location,
#               habitat type, order of occurence, etc. within a single UID.
#               For NLA, transect is used for this purpose.
#       PARAMETER - parameter name, which identifies the variables used in
#                   calculations. In wide data frame format, this argument
#                   would be used to name columns.  It is assumed that this
#                   argument has the following values: AM_EMERGENT, AM_FLOATING,
#                   AM_SUBMERGENT, and AM_TOTALCOVER.
#       RESULT - parameter values, which are the values used in calculations.
# Output:
#   A data frame that contains the following columns:
#     UID - universal ID value
#     PARAMETER - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
################################################################################

  # Print initial messages
  cat('Aquatic Macrophyte calculations:\n')
  intermediateMessage('Aquatic Macrophyte mets', loc='start')

  # Subset the input data frame
  amData <- subset(df, PARAMETER %in% c('AM_EMERGENT', 'AM_FLOATING'
                                     ,'AM_SUBMERGENT', 'AM_TOTALCOVER'
                                     )
                    ,c(UID,STATION,PARAMETER,RESULT)
                    )

    # Create tables for converting field values to calculation values
    cover04<-data.frame(field=c(NA,'0','1','2','3','4')
                       ,calc=c(NA,0,0.05,0.25,0.575,0.875)
                       ,stringsAsFactors=FALSE
                       )

    presence04<-data.frame(field=c(NA,'0','1','2','3','4')
                          ,calc=c(NA,0,1,1,1,1)
                          ,stringsAsFactors=FALSE
                          )

    intermediateMessage('.1')

    # Calculate fractional presence and cover values of individual cover classes
	indivCovers <- metsAquaticMacrophytes.individualCover(amData, presence04, cover04)
	
	intermediateMessage('.2')
	
	
    # Calculate interquartile range of cover in total layer
	amCover<-merge(amData, cover04
				  ,by.x='RESULT'
				  ,by.y='field'
				  ,all.x=TRUE, sort=FALSE
				  )
	tt<-subset(amCover, PARAMETER=='AM_TOTALCOVER')
    iqrCover<-aggregate(list(RESULT=tt$calc)
                       ,list(UID=tt$UID)
                       ,iqr
                       )
 	iqrCover$PARAMETER <- 'AMIQALL'   
    

    # Calculate interdecile range of cover in total layer
    idrCover<-aggregate(list(RESULT = tt$calc)
                       ,list(UID = tt$UID)
                       ,idr
                       )
    idrCover$PARAMETER <- 'AMIDALL'
    				 
    intermediateMessage('.3')


    # Calculate index of total macrophyte cover, defined as the mean of
    # the sum of cover values at each transect
	amiTotal <- metsAquaticMacrophytes.indices(amCover)

    intermediateMessage('.4')


    # combine metrics for aquatic macrophytes, sort result
    amMets <- within(rbind(indivCovers, iqrCover, idrCover, amiTotal)
	                ,RESULT <- as.character(RESULT)
					)
    intermediateMessage(' Done.', loc='end')

    return(amMets)
}


metsAquaticMacrophytes.individualCover <- function(df, presenceWeights, coverWeights)
# Determines fractional presence, fractional cover, cover sd and cover counts. 
# Returns dataframe with columns UID, PARAMETER, RESULT
{
	# Fractional presence
	amPresence<-merge(df
					 ,presenceWeights
					 ,by.x='RESULT'
					 ,by.y='field'
					 ,all.x=TRUE
					 ,sort=FALSE
					 )
	
	tt<-aggregate(list(RESULT = amPresence$calc)
				 ,list(UID = amPresence$UID
					  ,PARAMETER = amPresence$PARAMETER
					  )
				,mean, na.rm=TRUE
				)
	meanPresence<-within(tt
						,{PARAMETER <- ifelse(PARAMETER == 'AM_EMERGENT', 'AMFPEMERGENT'
									  ,ifelse(PARAMETER == 'AM_FLOATING', 'AMFPFLOATING'
									  ,ifelse(PARAMETER == 'AM_SUBMERGENT', 'AMFPSUBMERGENT'
									  ,ifelse(PARAMETER == 'AM_TOTALCOVER', 'AMFPALL', 'AMFPUNKNOWN'
									   ))))
						 }
						)
	
	intermediateMessage('a')
	
	
	# Mean, sd and counts of midpoint cover.  These are not normalized
	# since they are all independent categories.
	amCover<-merge(df, coverWeights
			,by.x='RESULT'
			,by.y='field'
			,all.x=TRUE, sort=FALSE
	)
	
	tt<-ddply(subset(amCover, grepl('^AM.+',PARAMETER))
			 ,.(UID,PARAMETER)
			 ,summarise
			 ,FC = mean(calc, na.rm=TRUE)
			 ,V  = sd(calc, na.rm=TRUE)
			 ,N  = length(na.omit(calc))
			 )
	coverMets <- within(melt(tt, c('UID','PARAMETER'), variable.name='met', value.name='RESULT')
			,{PARAMETER <- paste0('AM', met
								 ,ifelse(PARAMETER=='AM_TOTALCOVER', 'ALL', gsub('^AM_(.+)$', '\\1', PARAMETER))
								 )
			  met <- NULL
			 }
			)

	intermediateMessage('b')
			
	rc <- rbind(meanPresence, coverMets)
}


metsAquaticMacrophytes.indices <- function(df)
# Calculates AMITOTAL defined as the mean of the sum of cover values at each transect
# Returns dataframe with columns UID, PARAMETER, RESULT
{
	qq <- subset(df, PARAMETER %in% c('AM_EMERGENT', 'AM_FLOATING', 'AM_SUBMERGENT'))
	
	tt <- aggregate(qq$calc
				   ,list(UID = qq$UID
						,STATION = qq$STATION
						)
				   ,sum, na.rm=TRUE
				   )
	
	amiTotal <- aggregate(list(RESULT = tt$x)
						 ,list(UID = tt$UID)
						 ,mean, na.rm=TRUE
						 )
	amiTotal$PARAMETER <- 'AMITOTAL'
	
	return(amiTotal)
}



# end of file
