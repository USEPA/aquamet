metsStationInformation <- function(df) {

################################################################################
# Function: metsStationInformation
# Title: Calculate NLA Station Information Metrics
# Programmers: Curt Seeliger
#              Tom Kincaid
# Date: October 14, 2008
# Description:
#   This function calculates the station information portion of the physical
#   habitat metrics for National Lakes Assessment (NLA) data.  The function
#   requires a data frame containing validated physical habitat data collected
#   using the NLA protocol.  The passed data frame must contain records for all
#   stations sampled at each site, or the station counts used to calculate
#   island metrics will not be correct.  Note: The passed data frame contains
#   records for all stations sampled at each site, or the station counts used to
#   calculate island mets will not be correct.
# Function Revisions:
#   10/14/08 cws: Started.
#   03/08/13 cws: Copied from 2007 study and renamed.
#   01/28/14 cws: Started unit test development.
#   01/30/14 cws: Discovered that the station count used to determine SIFPISLAND 
#            is dependent on how (and whether) the input dataframe is subsetted 
#            from the body of phab data.  The 2007 unit test input data for this 
#            was modified to account for this problem.   Unit test for 2012 data
#            added, along with data standardization to convert 2012 data to 2007
#            coding.  Regression to 2007 results shows the following 
#            differences: There are 171 absent SI[NXV]DEPTH values due to 62 
#            UIDs that do not have any DEPTH_AT_STATION values recorded.  These 
#            differences are expected.  There are another 5 cases of SIFPISLAND 
#            (with values of zero) which are absent in earlier calculations. 
#            There are 5 cases of SIFPISLAND (7771,8017,8042,8177,8659) with 
#            different values suggesting a change in the denominator (number of 
#            transects).  I have not been able to track down the cause of this, 
#            however the old metrics code from 2007 agrees with the new values 
#            for these sites.  There are 60 differences in SI[NVX]DEPTH due 
#            solely to floating point precision differences.
#   06/12/14 tmk: Removed calls to the require() function.
# Arguments:
#   df = a data frame containing station information data.  The data frame must
#     include columns that are named as follows:
#       UID - universal ID value, which uniquely identifies the site location, 
#             date of visit, visit order, habitat type, etc. for which metrics 
#             will be calculated.  For NLA, site ID, year and visit number are
#             used for this purpose.
#       STATION - the subordinate ID value, which identifies the location,
#               habitat type, order of occurence, etc. within a single UID.
#               For NLA, transect is used for this purpose.
#       PARAMETER - parameter name, which identifies the variables used in
#                   calculations. In wide data frame format, this argument
#                   would be used to name columns.  It is assumed that this
#                   argument has the following values: ISLAND and
#                   DEPTH_AT_STATION.
#       RESULT - parameter values, which are the values used in calculations.
#       UNITS - parameter units, which identifies the units in which the
#               parameter values are recorded.
# Output:
#   A data frame that contains the following columns:
#     UID - universal ID value
#     PARAMETER - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
################################################################################

  # Print initial messages
  cat('Station Information calculations:\n')
  intermediateMessage('Station information mets', loc='start')
	
	island <- metsStationInformation.islandStations(df)
	stationDepths <- metsStationInformation.stationDepths(df)
	
	rc <- within(rbind(island, stationDepths), RESULT <- as.character(RESULT))

	intermediateMessage(' Done.', loc='end')
	
	return(rc)
}


metsStationInformation.islandStations <- function(df)
# calculate mets for stations at islands
{
	# Standardize values by converting to 2007-esque organization:
	# Y,YES becomes X, otherwise they are NA
	standardized <- within(df
						  ,RESULT <- ifelse(PARAMETER=='ISLAND' & 
										    (RESULT=='X' | grepl('^Y.*',RESULT))
				  						   ,'X'
										   ,NA
						   				   )
						  )

	# Determine number of stations in each lake
    ss <- aggregate(list(nSta = standardized$STATION)
                   ,list(UID = standardized$UID)
                   ,function(x) { count(unique(x)) }
                   )

    intermediateMessage('.1')


  	# Count islands in each site, and determine their fractional presence
  	IslData <- subset(standardized, PARAMETER=='ISLAND')

  	nn <- aggregate(list(nIsl = I(IslData$RESULT))
                   ,list(UID = IslData$UID)
                   ,count
                   )

    siIsland <- merge(ss, nn, by='UID', all=TRUE, sort=FALSE)
    siIsland <- within(siIsland
					  ,{RESULT <- ifelse(is.na(nIsl), 0, nIsl / nSta)
					    PARAMETER <- 'SIFPISLAND'
					    nIsl <- NULL
					    nSta <- NULL
				  	   }
		  			  )
    intermediateMessage('.2')

	return(siIsland)
}


metsStationInformation.stationDepths <- function(df)
# calculate mets for stations at islands
{
	# Standardize to include UNITS column if absent, and populate
	# it with assumed measurement units
	if('UNITS' %nin% names(df)) {
		df$UNITS <- 'm'
	}
	
  	# Characterize station depths, converting ft to m as necessary
  	depths <- subset(df, PARAMETER=='DEPTH_AT_STATION')
  	depths$RESULT <- as.numeric(depths$RESULT)
  	depths$UNITS <- trimws(tolower(depths$UNITS))
  	depths$RESULT <- ifelse(depths$UNITS=='ft'
                           ,as.numeric(depths$RESULT) * 0.3048
                           ,as.numeric(depths$RESULT)
                           )
    depths$RESULT[!(depths$UNITS %in% c('m','ft',''))] <- NA

  	xDepth <- aggregate(list(RESULT = as.numeric(depths$RESULT))
                       ,list(UID = depths$UID)
                       ,mean, na.rm=TRUE
                       )
  	xDepth$PARAMETER <- 'SIXDEPTH'

	
  	vDepth <- aggregate(list(RESULT = as.numeric(depths$RESULT))
                       ,list(UID = depths$UID)
                       ,sd, na.rm=TRUE
                       )
	vDepth$PARAMETER <- 'SIVDEPTH'
	
	
  	nDepth <- aggregate(list(RESULT = as.numeric(depths$RESULT))
                       ,list(UID = depths$UID)
                       ,count
                       )
	nDepth$PARAMETER <- 'SINDEPTH'
					 
  	intermediateMessage('.3')

  
  	# Combine calculations and return
	stationDepths <- rbind(xDepth, vDepth, nDepth)

  	return(stationDepths)
}



# end of file
