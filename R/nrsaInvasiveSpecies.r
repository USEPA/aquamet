nrsaInvasiveSpecies <- function(...) {

################################################################################
# Function: nrsaInvasiveSpecies
# Title: Calculate NRSA Invasive Species Metrics
# Programmers: Suzanne San Romani
#              Curt Seeliger
#              Tom Kincaid
# Date: February 10, 2010
# Description:
#   This function calculates the invasive species portion of the physical
#   habitat metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires a data frame containing the invasive species/legacy
#   riparian trees data file.
# Metrics:
#   f_myrspi = count of E_WTRMILF/count of transects
#   f_hydver = count of HYDRILLA/count of transects
#   f_eiccra = count of W_HYACINTH/count of transects
#   f_nympel = count of YLW_FLTHEAR/count of transects
#   f_lytsal = count of P_LSTRIFE/count of transects
#   f_arudon = count of G_REED/count of transects
#   f_butumb = count of FLWR_RUSH/count of transects
#   f_tamspp = count of SALT_CED/count of transects
#   f_rosmul = count of MF_ROSE/count of transects
#   f_eupesu = count of SPURGE/count of transects
#   f_none = count of NO_INVASIVES/count of transects
#   ip_count = sum(f_myrspi, f_hydver, f_eiccra, f_nympel, f_lytsal, f_arudon,
#                  f_butumb, f_tamspp, f_rosmul, f_eupesu)
# Function Revisions:
#   02/10/10 ssr: Created.
#   03/23/10 cws: Moved creation of test dataframes into separate functions.
#   03/25/10 cws: Changed diff() calls to dfCompare().
#   06/24/10 cws: Modified to handle odd case when transect has NO_INVASIVES
#            marked as well as an invasive species marked.  This shouldn't,
#            in the hopeful sense, make it through QA but we can assume a
#            species marked as present actually is present and safely ignore
#            the NO_INVASIVES check in these cases.
#   09/16/10 cws: Removing hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   11/02/10 cws: Modified to handle datasets with no NO_INVASIVES boxes
#            checked.  Updated unit test to check for this case.
#   07/26/12 tmk: Removed use of ODBC data connection and replaced with data
#            input from csv files using a call to function read.csv.  Added
#            argument tbl to the function to identify name of the data file.
#            Added argument NRSAdir to the function to identify the directory
#            from which the data file is read and to which the output metrics
#            file is written.
#   12/20/12 tmk: Modified data input to use a data frame containing the data
#            file rather than a csv file.  Modified output to be a data frame
#            rather than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frame to
#            character variables.
#   12/08/15 cws Updated calling interface, with corresponding update to unit test.
#            Uses elipsis argument (...) to allow inclusion of any species in the
#            calculations. Argument names are used to create the resulting
#            metric names (f_argname1, f_argname2, etc.).  If there is an argument
#            named 'none', those values will not be included in the ip_score 
#            calculations.  Additionally, values for individual species are now
#            returned when they are zero; previously these values were not 
#            included in the metrics.
#
# Arguments:
#   invasivelegacy = a data frame containing the invasive species/legacy
#     riparian trees data file.  The data frame must include columns that are
#     named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   Note that possible values for variables in the input data frame are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   nrsaInvasiveSpecies.1 - calculate metrics
################################################################################

# # Print an initial message
#   cat('Invasive Species calculations:\n')
# 
# # Convert factors to character variables in the invasivelegacy data frame
#   intermediateMessage('.1 Convert factors to character variables.', loc='end')
#   invasivelegacy <- convert_to_char(invasivelegacy)
# 
# # Subset the invasivelegacy data frame to retain desired values in the column
# # named PARAMETER and retain the set of desired columns
#   intermediateMessage('.2 Subset the data frame.', loc='end')
#   df <- subset(invasivelegacy, PARAMETER %in%
#                c('E_WTRMILF', 'HYDRILLA', 'W_HYACINTH', 'YLW_FLTHEAR',
#                  'P_LSTRIFE', 'G_REED', 'FLWR_RUSH', 'SALT_CED', 'MF_ROSE',
#                  'SPURGE', 'NO_INVASIVES'),
#                select=c('UID', 'TRANSECT', 'PARAMETER', 'RESULT'))
# 
# #  Calculate the metrics
#   intermediateMessage('.3 Call function nrsaInvasiveSpecies.1.', loc='end')
#   mets <- nrsaInvasiveSpecies.1(df)
#   row.names(mets) <- 1:nrow(mets)
# 
# # Print an exit message
#   intermediateMessage('Done.', loc='end')
# 
# # Return results
#   return(mets)
# }
# 
# 
# 
# nrsaInvasiveSpecies.1 <- function(df) {

    # Sanity checks: make sure all arguments are named, perhaps by creating names 
    # for unnamed arguments.  If the 4th argument has no name, call it 'unknown4'

    # Make sure all arguments are NULL or have columns SITE, TRANSECT, VALUE
    intermediateMessage('Invasive plant mets', loc='start')
    speciesList <- list(...)
    allMets <- NULL
    if(length(speciesList) > 0) {
        for(spName in names(speciesList)) {
            intermediateMessage(sprintf('. %s', spName))
            spData <- speciesList[[spName]]
            if(is.null(spData)) next;
            spMets <- nrsaInvasiveSpecies.singleSpecies(spData) %>%
                      mutate(METRIC=sprintf('f_%s', spName))
            allMets <- rbind(allMets, spMets)
        }
        
        intermediateMessage('. ip_score')
        ipScore <- nrsaInvasiveSpecies.ip_score(allMets)
        allMets <- rbind(allMets, ipScore)
    }

    intermediateMessage(' Done.', loc='end')

    return(allMets)
}


nrsaInvasiveSpecies.singleSpecies <- function(spData) 
# Determines average occurence for a single species. 
{
    # Normalize presence/absence data, but allow for use with cover values as 
    # such as 0.25 as well.
    rc <- spData %>% 
          mutate(VALUE = as.numeric(ifelse(VALUE %in% c('X','Y'), 1,
                                    ifelse(VALUE %in% c('N',''),  0, VALUE
                                    ))
                                   )) %>%
          ddply('SITE', summarise
               ,VALUE = protectedMean(VALUE, na.rm=TRUE)
               )
    
    return(rc)
}


nrsaInvasiveSpecies.singleSpeciesTest <- function()
# unit test for nrsaInvasiveSpecies.singleSpecies
{
    tc <- textConnection("SITE TRANSECT VALUE
                          a    A        0       # Site with 0/1 data
                          a    B        1
                          a    C        1
                          a    D        1
                          a    E        0
                          a    F        0
                          a    G        0
                          a    H        1
                          a    I        0
                          a    J        1
                          a    K        0
                          b    A        0       # Site with character data
                          b    B        X
                          b    C        X
                          b    D        Y
                          b    E        ''
                          b    F        ''
                          b    G        ''
                          b    H        X
                          b    I        ''
                          b    J        Y
                          b    K        ''
                          c    A        0       # Site with 0/1/NA/'' data
                          c    B        NA
                          c    C        1
                          c    D        1
                          c    E        0
                          c    F        ''
                          c    G        0
                          c    H        1
                          c    I        0
                          c    J        1
                          c    K        0
                          d    A        0       # Site with character and NA data
                          d    B        NA
                          d    C        X
                          d    D        Y
                          d    E        ''
                          d    F        NA
                          d    G        ''
                          d    H        X
                          d    I        ''
                          d    J        Y
                          d    K        ''
                          e    A        0       # Site with fractional and NA data
                          e    B        NA      # just to see if it works.
                          e    C        .3
                          e    D        .5
                          e    E        0
                          e    F        NA
                          e    G        .1
                          e    H        .1
                          e    I        0
                          e    J        .2
                          e    K        .7
                         ")
    testData <- read.table(tc, header=TRUE, stringsAsFactors=FALSE, row.names=NULL)
    rm(tc)

    expected <- data.frame(SITE=c('a', 'b', 'c', 'd','e')
                          ,VALUE=c(5/11, 5/11, 4/10, 4/9, 1.9/9)
                          ,stringsAsFactors=FALSE
                          )
    actual <- nrsaInvasiveSpecies.singleSpecies(testData)
    checkEquals(expected, actual, "Incorrect ip_score results")
}


nrsaInvasiveSpecies.ip_score <- function(individualMets)
# Calculate ip_score as the sum of occurrences of individual species, not 
# including f_none if it appears.
{   
    sitesWithSpecies <- ddply(subset(individualMets, METRIC!='f_none')
                        ,c('SITE')
                        ,summarise
                        ,VALUE = protectedSum(VALUE, na.rm=TRUE)
                        ,METRIC = 'ip_score'
                        )
    sitesWithoutSpecies <- subset(individualMets
                                 ,METRIC == 'f_none' & 
                                  #VALUE == 1 & 
                                  SITE %nin% sitesWithSpecies$SITE
                                 )
    if(nrow(sitesWithoutSpecies) == 0) {
        sitesWithoutSpecies <- NULL
    } else {
        sitesWithoutSpecies <- mutate(sitesWithoutSpecies
                                     ,VALUE = 0
                                     ,METRIC = 'ip_score'
                                     )
    }

    rc <- rbind(sitesWithSpecies, sitesWithoutSpecies)
    return(rc)
}


nrsaInvasiveSpecies.ip_scoreTest <- function()
# unit test for nrsaInvasiveSpecies.ip_score
{
    tc <- textConnection("SITE METRIC VALUE
                          1    f_a    .0    # site with f_none present = 0
                          1    f_b    .1
                          1    f_c    .2
                          1    f_d    .3
                          1    f_none .0
                          2    f_a    .1    # site with f_none absent
                          2    f_b    .2
                          2    f_c    .3
                          2    f_d    .4
                          3    f_a    .0    # site with f_none present = 1
                          3    f_b    .1
                          3    f_c    .2
                          3    f_d    .3
                          3    f_none  1
                          4    f_a    .0    # site with f_none present = NA
                          4    f_b    .1
                          4    f_c    .2
                          4    f_d    .3
                          4    f_none NA
                          5    f_a    .0    # site with NA value in data and f_none present = .7
                          5    f_b    .1
                          5    f_c    NA
                          5    f_d    .3
                          5    f_none .7
                          6    f_none  0    # site with only f_none, value is 0
                          7    f_none  1    # site with only f_none, value is 1
                          8    f_none NA    # site with only f_none, value is NA
                         ")
    testData <- read.table(tc, header=TRUE, stringsAsFactors=FALSE, row.names=NULL)
    rm(tc)
    
    expected <- data.frame(SITE=1:8
                          ,VALUE=c(0.6, 1, 0.6, 0.6, 0.4, 0, 0, 0)
                          ,METRIC='ip_score'
                          ,stringsAsFactors=FALSE
                          )
    actual <- nrsaInvasiveSpecies.ip_score(testData)
    checkEquals(expected, actual, "Incorrect ip_score results")
}



old <- function(df) {

df$RESULT <- ifelse(df$RESULT=='X' | df$RESULT == 'Y', 1, df$RESULT)              
#   Creating counts of individual invasive species
aa <- ddply(df,c('UID','PARAMETER'),summarise,METRIC=unique(PARAMETER),RESULT=length(na.omit(RESULT)))
aa$PARAMETER <- NULL
# aa <- aggregate(list(RESULT=df$RESULT), by=list(UID=df$UID, METRIC=df$PARAMETER), count)

##Creating count of transects observed
bb <- subset(df, select=c('UID', 'TRANSECT'))
cc <- bb[!duplicated(bb),]
dd <- ddply(cc,c('UID'),summarise,tranCount=length(na.omit(TRANSECT)))
# dd <- aggregate(list(tranCount=cc$TRANSECT), list(UID=cc$UID), count)
ee <- merge(aa,dd)

#    Creating metrics for individual species
#   Because individual counts are not kept with the calculated metrics,
#   we are changing the species name to the species metric name
ee$METRIC <- ifelse(ee$METRIC=='E_WTRMILF', 'f_myrspi', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='HYDRILLA', 'f_hydver', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='W_HYACINTH', 'f_eiccra', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='YLW_FLTHEAR', 'f_nympel', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='P_LSTRIFE', 'f_lytsal', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='G_REED', 'f_arudon', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='FLWR_RUSH', 'f_butumb', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='SALT_CED', 'f_tamspp', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='MF_ROSE', 'f_rosmul', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='SPURGE', 'f_eupesu', ee$METRIC)
ee$METRIC <- ifelse(ee$METRIC=='NO_INVASIVES', 'f_none', ee$METRIC)
#   All invasive species metrics are number of observations within a site
#   divided by the number of transects observed during site visit
ee$RESULT <- ee$RESULT/ee$tranCount
#   Done with count of transects, deleting it
ee$tranCount <- NULL

#   Calculating ip_score, which is the sum of all metrics of invasive species
#   present.
ff <- ddply(subset(ee,METRIC!='f_none'),c('UID'),summarise,METRIC='ip_score',RESULT=sum(RESULT))
# ff <- aggregate(list(RESULT=ee[ee$METRIC != 'f_none',]$RESULT),
#                      list(UID=ee[ee$METRIC != 'f_none',]$UID), sum)
# ff$METRIC <- 'ip_score'
# ff <- ff[,c('UID','METRIC','RESULT')]

#   If there are no invasive species present, it will not have been calculated
#   in the previous step, none must equal 1, and therefore ip_score must equal 0.
#   This does not take into account transects in which NO_INVASIVES were checked
#   along with an invasive.  This *should* be caught during QA, but if it isn't
#   we'll assume the invasive actually exists and ignore the NO_INVASIVES flag.
gg <- subset(ee, METRIC=='f_none' & RESULT == 1)
if(nrow(gg)==0) {
    gg <- NULL
} else {
    gg$METRIC <- 'ip_score'
    gg$RESULT <- 0
    gg <- subset(gg, !(UID %in% ff$UID))
}

#    Creating final file -- indivual species metrics, ip_score when invasive
#   species are present, and ip_score when no invasive species are present.
mhinplnt <- rbind(ee,ff,gg)
}



# end of file
