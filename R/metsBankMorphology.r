metsBankMorphology <- function(bankgeometry, visits) {

################################################################################
# Function: metsBankMorphology
# Title: Calculate NRSA Bank Morphology Metrics
# Programmers: Marlys Cappert
#              Suzanne San Romani
#              Curt Seeliger
#              Tom Kincaid
# Date: January 21, 2010
# Description:
#   This function calculates the bank morphology portion of the physical habitat
#   metrics for National Rivers and Streams Assessment (NRSA) data.  The
#   function requires data frames containing the bank geometry and stream
#   verification form data files.
# Wadeable Metrics:
#   bka_q1, bka_q3, bkun_q1, bkun_q3, intqbka, intqbkun, medbkun, medbk_a,
#   n_ba, n_un, sdbk_a, sdun, xbka, sdun, sbka, xun
# Boatable Metrics:
#   bangmode, bap_low, bap_med, bap_mis,bap_stp, bap_vst, n_ba
# Function Revisions:
#   01/21/10 mrc: Started.
#   01/25/10 mrc: Completed metrics. Wrote tests.
#   03/16/10 mrc: Replace external text files with openTextConnection
#            instructions.
#   03/17/10 mrc: Replaced upData calls with rename.
#   03/18/10 ssr: Added boatable n_ba to data for export.
#   03/22/10 ssr: Moved creation of unit test dataframes to separate
#            functions.
#   03/25/10 cws: Changed diff() calls to dfCompare().
#   09/16/10 cws: Removed hardcoding of NRSA database name, using NRSAdbName
#            instead.
#   04/05/12 cws: Removed calculation of n_w (only done for for boatables), as 
#            this is done in metsChannelMorphology() for both protocols.  Unit
#            test modified accordingly, and rewritten to eliminate production
#            of NAs by coercion, which had the effect of excluding text metric 
#            bangmode from the test.
#   07/26/12 tmk: Removed use of ODBC data connection and replaced with data
#            input from csv files using a call to function read.csv.  Added
#            argument tbl to the function to identify names of the data files.
#            Added argument NRSAdir to the function to identify the directory
#            from which data files are read and to which the output metrics file
#            is written. In function metsBankMorphologyTest.process, renamed
#            argument by to byVars in the call to dfCompare.
#   09/07/12 tmk: Modified data input to use data frames containing data files
#            rather than csv files.  Modified output to be a data frame rather
#            than a csv file.  Removed RUnit functions.
#   01/11/13 tmk: Inserted code to convert factors in the input data frames to
#            character variables.
# Metrics Revisions:
#   10/25/02 cws River bank angle mets changed.  Calculation of mean, median,
#            and quartile values based on arithmetic midpoints of bins is
#            arguably silly, and are replaced by percent of reach in each
#            category and the distributional mode as described by Zar
#            (2ed), p 23.  This makes the calculations completely different
#            for rivers vs. streams.
# Arguments:
#   bankgeometry = a data frame containing the bank geometry data file.  The
#     data frame must include columns that are named as follows:
#       UID - universal ID value
#       SAMPLE_TYPE - sample type
#       TRANSECT - transect label
#       TRANSDIR - transverse location along transect
#       PARAMETER - identifier for each measurement, assessment, score, etc.
#       RESULT - measurement associated with PARAMETER column
#       UNITS - units of the RESULT measurement
#       FLAG - flag
#   visits = a data frame containing the stream verification form data file.
#     The data frame contains a protocol value for each UID value.  It also
#     should include columns that relate UID to values meaningfull to the user,
#     e.g., site ID, date collected, and visit number.  The data frame must
#     include columns that are named as follows:
#       UID - universal ID value
#       VALXSITE - protocol used during a site visit (BOATABLE, PARBYBOAT,
#         ALTERED, INTWADE, PARBYWADE, WADEABLE)
#   Note that possible values for variables in the input data frames are
#   provided in the document named "NRSA Documentation.pdf" included in the help
#   directory for the package.
# Output:
#   Either a data frame when metric calculation is successful or a character
#   string containing an error message when metric calculation is not
#   successful.  The data frame contains the following columns:
#     UID - universal ID value
#     METRIC - metric name
#     RESULT - metric value
# Other Functions Required:
#   intermediateMessage - print messages generated by the metric calculation
#      functions
#   siteProtocol - determine sampling protocol values
#   metsBankMorphology.1 - calculate metrics
################################################################################

# Print an initial message
  cat('Bank Morphology calculations:\n')

# Convert factors to character variables in the input data frames
  intermediateMessage('.1 Convert factors to character variables.', loc='end')
  bankgeometry <- convert_to_char(bankgeometry)
  visits <- convert_to_char(visits)

# Determine protocol used for each site
  intermediateMessage('.2 Set protocols.', loc='end')
  protocols <- siteProtocol(unique(bankgeometry$UID), visits)

# Calculate the metrics
  intermediateMessage('.3 Call function metsBankMorphology.1.', loc='end')
  mets <- metsBankMorphology.1(bankgeometry, protocols)
  row.names(mets) <- 1:nrow(mets)

# Print an exit message
  intermediateMessage('Done.', loc='end')

# Return results
  return(mets)
}



metsBankMorphology.1 <- function(df1, protocols) {


# Returns a dataframe of calculations if successful or a character string 
# describing the problem if one was encountered.
#
# ARGUMENTS:
# df1       dataframe of the bankmorphology data.
# protocols dataframe relating UID to the sampling protocol used at that site
#

  intermediateMessage('BankMorphology mets', loc='start')
  #initialize datasets for final rbind
  boatmets<-NULL
  stream<-NULL

  #start with splitting up streams and rivers.

  mm <- merge(df1, protocols, by='UID', all.x=TRUE, all.y=FALSE)
   
  mmstr <- subset (mm, mm$PROTOCOL=='WADEABLE')


  #angle (must reshape to do these calculations)

  if (nrow(mmstr)>0) {
    ang <- subset (mmstr, mmstr$PARAMETER=='ANGLE')
    ang$RESULT <- as.numeric(ang$RESULT)  ## NAs by coersion

    ct <- aggregate(ang$RESULT
                       ,list('UID'=ang$UID
                       )
                       ,count
                       )
                       
    ct$METRIC <- 'n_ba'
    ct <- rename(ct, 'x', 'RESULT')

    mn <- aggregate(ang$RESULT
                       ,list('UID'=ang$UID
                       )
                       ,mean , na.rm=TRUE
                       )
    mn$METRIC <- 'xbka'
    mn <- rename(mn, 'x', 'RESULT')

    stt <- aggregate(ang$RESULT
                       ,list('UID'=ang$UID
                       )
                       ,sd  , na.rm=TRUE
                       )
    stt$METRIC <- 'sdbk_a'
    stt <- rename(stt, 'x', 'RESULT')
                       
    iqq <- aggregate(ang$RESULT
                       ,list('UID'=ang$UID
                       )
                       ,iqr
                       )
    iqq$METRIC <- 'intqbka'
    iqq <- rename(iqq, 'x', 'RESULT')

    med <- aggregate(ang$RESULT
                       ,list('UID'=ang$UID
                       )
                       ,median , na.rm=TRUE
                       )
                       
    med$METRIC <- 'medbk_a'
    med <- rename(med,'x', 'RESULT')
    
    upq1 <- aggregate(ang$RESULT
                       ,list ('UID'=ang$UID
                       )
                       ,quantile, 0.25, na.rm=TRUE, names=FALSE, type=2
                       )
                       
    upq1$METRIC <- 'bka_q1'
    upq1 <- rename(upq1, 'x', 'RESULT')

    upq3 <- aggregate(ang$RESULT
                     ,list ('UID'=ang$UID)
                     ,quantile, .75, na.rm=TRUE, names=FALSE, type=2
                     )
    upq3$METRIC <- 'bka_q3'
    upq3 <- rename(upq3, 'x', 'RESULT')

    #put these together

    bkangle <- rbind (ct, mn, stt, iqq, med, upq1, upq3)
    intermediateMessage('.1')

    #do this same step for undercut (streams)

    unct <- subset (mmstr, mmstr$PARAMETER=='UNDERCUT')
    unct$RESULT <- as.numeric(unct$RESULT)

    ct <- aggregate(unct$RESULT
                       ,list('UID'=unct$UID
                       )
                       ,count
                       )

    ct$METRIC <- 'n_un'
    ct <- rename(ct, 'x', 'RESULT')

    mn <- aggregate(unct$RESULT
                       ,list('UID'=unct$UID
                       )
                       ,mean , na.rm=TRUE
                       )
    mn$METRIC <- 'xun'
    mn <- rename(mn,'x', 'RESULT')

    stt <- aggregate(unct$RESULT
                       ,list('UID'=unct$UID
                       )
                       ,sd , na.rm=TRUE
                       )
    stt$METRIC <- 'sdun'
    stt <- rename(stt, 'x', 'RESULT')

    iqq <- aggregate(unct$RESULT
                       ,list('UID'=unct$UID
                       )
                       ,iqr
                       )
    iqq$METRIC <- 'intqbkun'
    iqq <- rename(iqq, 'x', 'RESULT')

    med <- aggregate(unct$RESULT
                       ,list('UID'=unct$UID
                       )
                       ,median , na.rm=TRUE
                       )

    med$METRIC <- 'medbkun'
    med <- rename(med, 'x', 'RESULT')

    upq1 <- aggregate(unct$RESULT
                       ,list ('UID'=unct$UID
                       )
                       ,quantile, 0.25, na.rm=TRUE, names=FALSE, type=2
                       )

    upq1$METRIC <- 'bkun_q1'
    upq1 <- rename(upq1, 'x', 'RESULT')

    upq3 <- aggregate(unct$RESULT
                       ,list ('UID'=unct$UID
                       )
                       ,quantile, 0.75, na.rm=TRUE, names=FALSE, type=2
                       )
    upq3$METRIC <- 'bkun_q3'
    upq3 <- rename(upq3, 'x', 'RESULT')

    #put these together

    undercut <- rbind (ct, mn, stt, iqq, med, upq1, upq3)
    intermediateMessage('.2')


    #put together undercut and angle

    stream <- rbind(bkangle, undercut)
    intermediateMessage('.3')
  }
#   iq4step  <- quantile(ang$RESULT, type=2, na.rm=TRUE, names=FALSE)
   
#   mmstrw <- reshape(mmstr, idvar='UID', direction='wide', timevar='METRIC')
#  names(mmstr) <- gsub('RESULT\\.', '', names(mmstr))


#Rivers (bank angle and other mets.)

#bang_mode, bap_low, bap_med, bap_mis, bap_stp, bap_vst, n_ba

  mmboat <- subset (mm, mm$PROTOCOL=='BOATABLE')
  
  angb <- subset (mmboat, mmboat$PARAMETER=='ANGLE')

  if(nrow(angb)>0) {
    ct <- aggregate(angb$RESULT
                   ,list('UID'=angb$UID)
                   ,count
                   )
    ct$METRIC <- 'n_ba'
    ct <- rename(ct, 'x', 'n_ba')
    intermediateMessage('.4')

    #use the total ang count to get other counts

    bap_low <- subset (mmboat, mmboat$PARAMETER=='ANGLE' )
    bap_low <- aggregate(bap_low$RESULT
                        ,list('UID'=bap_low$UID)
                        ,function (RESULT) {sum(RESULT=='0-5')}
                        )
    bap_low <- rename(bap_low, 'x', 'low')
    
    
    bb <- merge(ct, bap_low,  by='UID', all.x=TRUE, all.y=FALSE)
    intermediateMessage('.5')


    bb$RESULT <- (bb$low/bb$n_ba) * 100
    bb$low <- NULL
    bb$n_ba <- NULL
    bb$METRIC <- NULL
    bb$METRIC <- 'bap_low'

    bap_med <- subset (mmboat, mmboat$PARAMETER=='ANGLE')
    bap_med <- aggregate(bap_med$RESULT
                        ,list('UID'=bap_med$UID)
                        ,function (RESULT) {sum(RESULT=='5-30')}
                        )
    bap_med <- rename(bap_med, 'x', 'med')
    bb1 <- merge(ct, bap_med,  by='UID', all.x=TRUE, all.y=FALSE)
    
    intermediateMessage('.6')

    if(nrow(bb1)>0) {
      bb1$RESULT <- (bb1$med/bb1$n_ba) *100
      bb1$med <- NULL
      bb1$n_ba <- NULL
      bb1$METRIC <- NULL
      bb1$METRIC <- 'bap_med'
    }
 
    bap_stp <- subset (mmboat, mmboat$PARAMETER=='ANGLE' )
    bap_stp <- aggregate(bap_stp$RESULT
                        ,list('UID'=bap_stp$UID)
                        , function (RESULT) {sum(RESULT=='30-75')}
                        )
    bap_stp <- rename(bap_stp, 'x', 'stp')
      
    bb2 <- merge(ct, bap_stp,  by='UID', all.x=TRUE, all.y=FALSE)
    
    if(nrow(bb2)>0) {
      bb2$RESULT <- (bb2$stp/bb2$n_ba) *100
      bb2$stp <- NULL
      bb2$n_ba <- NULL
      bb2$METRIC <- NULL
      bb2$METRIC <- 'bap_stp'
    }
 
    bap_vst <- subset (mmboat, mmboat$PARAMETER=='ANGLE' )
    bap_vst <- aggregate(bap_vst$RESULT
                        ,list('UID'=bap_vst$UID)
                        ,function (RESULT) {sum(RESULT=='75-100')}
                        )
    bap_vst<- rename(bap_vst, 'x', 'vst')
    bb3 <- merge(ct, bap_vst,  by='UID', all.x=TRUE, all.y=FALSE)
    
    intermediateMessage('.7')

    if(nrow(bb3)>0) {
      bb3$RESULT <- (bb3$vst/bb3$n_ba) *100
      bb3$vst <- NULL
      bb3$n_ba <- NULL
      bb3$METRIC <- NULL
      bb3$METRIC <- 'bap_vst'
    }
 
    # Configuring ct for rbind
    ct <- rename(ct,'n_ba','RESULT')
    ct <- subset(ct, select=c('UID','METRIC','RESULT'))

    intermediateMessage('.8')

    boat <- rbind (bb, bb1,bb2,bb3,ct)
      
    intermediateMessage('.9')

    #work on the BANGMODE code for rivers.
    bang <- subset(df1
                  ,PARAMETER=='ANGLE' &
                   RESULT %in% c('0-5','5-30','30-75','75-100')
                  )

    tt <- aggregate(bang$RESULT=='0-5'
                   ,list('UID'=bang$UID)
                   ,mean, na.rm=TRUE
                   )
    lowbap <- rename(tt, 'x', 'xlow')

    tt <- aggregate(bang$RESULT=='5-30'
                   ,list('UID'=bang$UID)
                   ,mean, na.rm=TRUE
                   )
    medbap <- rename(tt, 'x', 'xmed')

    tt <- aggregate(bang$RESULT=='30-75'
                   ,list('UID'=bang$UID)
                   ,mean, na.rm=TRUE
                   )
    stpbap <- rename(tt, 'x', 'xstp')

    tt <- aggregate(bang$RESULT=='75-100'
                   ,list('UID'=bang$UID)
                   ,mean, na.rm=TRUE
                   )
    vstbap <- rename(tt, 'x', 'xvst')

 
    intermediateMessage('.10')
  
    # Determine color mode (most common bank angle)
    fracbangmode<-merge(lowbap, medbap
                       ,by='UID'
                       ,all=TRUE
                       ,sort=FALSE
                       )
    fracbangmode<-merge(fracbangmode, stpbap
                       ,by='UID'
                       ,all=TRUE
                       ,sort=FALSE
                       )
    fracbangmode<-merge(fracbangmode, vstbap
                       ,by='UID'
                       ,all=TRUE
                       ,sort=FALSE
                       )

    intermediateMessage('.11')


    modebang <- subset(fracbangmode, select='UID')
    modebang$bsobang <- NA
    for(i in 1:nrow(modebang)) {
      modebang$bsobang[i] <- modalClass(fracbangmode[i,]
                                       ,c('xlow','xmed','xstp','xvst'
                                         )
                                       ,c('0-5','5-30','30-75','75-100'
                                         )
                                       )
    }

    intermediateMessage('.12')

    modebang$METRIC <- 'bangmode'
    modebang <- rename(modebang, 'bsobang', 'RESULT')
    
    modebang$RESULT <- ifelse(modebang$RESULT =='0-5', 'low', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='5-30', 'med', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='30-75', 'stp', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='75-100', 'vst', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='0-5, 5-30', 'low-med', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='5-30, 30-75', 'med-stp', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT =='30-75, 75-100', 'stp-vst', modebang$RESULT)
    modebang$RESULT <- ifelse(modebang$RESULT %in% c('low', 'med','stp', 'vst'
                                                    ,'low-med','med-stp', 'stp-vst'
                                                    )
                             ,modebang$RESULT, 'None'
                             )

    boatmets <- rbind (modebang, boat)
 
  }

  metsfakeo <- rbind (boatmets, stream)
 
  intermediateMessage('  Done.', loc='end')
  return(metsfakeo)

}



# end of file
